	AREA MYDATA, DATA, READWRITE 

RCC_BASE		EQU		0x40023800
RCC_AHB1ENR		EQU		RCC_BASE + 0x30
RCC_APB2ENR		EQU		RCC_BASE + 0x44



GPIOA_BASE 		EQU   	0x40020000
GPIOA_MODER     EQU    	GPIOA_BASE
GPIOA_ODR  		EQU   	GPIOA_BASE + 0x14
GPIOA_BSRR		EQU		GPIOA_BASE + 0x18
GPIOA_AFRL		EQU		GPIOA_BASE + 0x20
GPIOA_OTYPER 	EQU		GPIOA_BASE + 0x04
GPIOA_OSPEEDR	EQU		GPIOA_BASE + 0x08



GPIOB_BASE 		EQU 	0x40020400
GPIOB_MODER     EQU     GPIOB_BASE
GPIOB_ODR     	EQU     GPIOB_BASE + 0x14
GPIOB_OTYPER	EQU		GPIOB_BASE + 0x04
GPIOB_OSPEEDR	EQU		GPIOB_BASE + 0x08
GPIOB_PUPDR		EQU		GPIOB_BASE + 0x0C
GPIOB_IDR 		EQU		GPIOB_BASE + 0x10



GPIOC_BASE      EQU    	0x40020800
GPIOC_MODER 	EQU 	GPIOC_BASE
GPIOC_IDR 		EQU 	GPIOC_BASE + 0x10
GPIOC_PUPDR	 	EQU 	GPIOC_BASE + 0x0C
GPIOC_ODR    	EQU     GPIOC_BASE + 0x14
GPIOC_OTYPER	EQU		GPIOC_BASE + 0x04
GPIOC_OSPEEDR	EQU 	GPIOC_BASE + 0x08
	
	
	
	
SPI1_BASE		EQU		0x40013000
SPI1_CR1		EQU		SPI1_BASE
SPI1_SR			EQU 	SPI1_BASE + 0x08
SPI1_DR			EQU 	SPI1_BASE + 0x0C	
	


INTERVAL_1MS	EQU		0xFA0
INTERVAL_10MS	EQU		0x9C40
INTERVAL_100MS	EQU		0x61A80
INTERVAL_1000MS EQU 	0x3D0900
INTERVAL_10S	EQU 	0x2625A00
SCREEN_WIDTH     EQU 480
SCREEN_HEIGHT    EQU 320
TILE_WIDTH      EQU 32
TILE_HEIGHT     EQU 32
SPRITE_X	DCD		100
SPRITE_Y	DCD		100
SPIDER1_X	DCD	0
SPIDER1_Y	DCD	0
SPIDER2_X	DCD	0
SPIDER2_Y	DCD	0
SPIDER3_X	DCD	0
SPIDER3_Y	DCD	0
FLAGSPIDER DCD 0
FLAGSPIDER2 DCD 1
FLAGSPIDER3 DCD 0
TILE_X		DCD     0
TILE_Y		DCD		0
SPRITE_HEIGHT 	DCW	0
SPRITE_WIDTH	DCW	0

ISSHOT DCD 0	
BULLET_X DCD 240
BULLET_Y DCD 0
RESET_X DCD 0
RESET_Y DCD 0
RESET_H DCW 0
RESET_W DCW 0
NEXT_BULLET DCD 144,176,208,240,272,304,336
NEXT_BULLET_INDEX DCD 0	
GAMEOVERFLAG DCD 0
MAIN_CAR_X	DCW		0x70 ; 112h
MAIN_CAR_Y	DCW		0xA0 ; 160h
COMP_CAR_X 	DCW 	0X00
COMP_CAR_Y 	DCW		0X00
ORIENTATION_MAIN 		DCW 	0x00 
ORIENTATION_COMP     	DCW 	0x00
	
	


HORIZONTAL_TRAIL_COUNT	DCW	0X00
VERTICAL_TRAIL_COUNT	DCW	0X00
;===============NEON_CYCLES VARIABLES===============================================================
PLAYER_1_SCORE			DCW		0x00  ; MAIN PLAYER SCORE
PLAYER_2_SCORE			DCW		0x00  ; SECOND PLAYER SCORE
MAIN_COLLIDED		DCW		0x00  ; BOOL COLLIDED_1ST_PLAYER
COMP_COLLIDED		DCW		0x00  ; BOOL COLLIDED_2ND_PLAYER
;=====================================================================================================

		
;the following are pins connected from the TFT to our EasyMX board
;RD = PA10		Read pin	--> to read from touch screen input 
;WR = PA11		Write pin	--> to write data/command to display
;RS = PA12		Command pin	--> to choose command or data to write
;CS = PA15		Chip Select	--> to enable the TFT, lol	(active low)
;RST= PA8		Reset		--> to reset the TFT (active low)
;D0-7 = PA0-7	Data BUS 0-7	--> Put your command or data on this bus
;D8-15 = PB0-7	Data BUS 8-15	--> Put your command or data on this bus



;just some color codes, 16-bit colors coded in RGB 565
BLACK	EQU   	0x0000
BLUE 	EQU  	0x001F
RED  	EQU  	0xF800
RED2   	EQU 	0x4000
GREEN 	EQU  	0x07E0
CYAN  	EQU  	0x07FF
MAGENTA EQU 	0xF81F
YELLOW	EQU  	0xFFE0
WHITE 	EQU  	0xFFFF
GREEN2 	EQU 	0x4326
CYAN2 	EQU  	0x07FF
GREY 	EQU		0xad13
BLUE_TRAIL EQU 	0x41DE
CYAN_TRAIL EQU 0x0469
RED_TRAIL     EQU    0xB800
RED_TRAIL2    EQU    0xE001 

	

	EXPORT __main
	IMPORT NEON_TITLE
	IMPORT BG_ARRAY
	IMPORT NEON_START
	IMPORT GRASS
	IMPORT ROAD
	IMPORT BULLET_CHAR_DOWN
	IMPORT BULLET_CHAR_UP
	IMPORT BULLET_CHAR_RIGHT
	IMPORT BULLET_CHAR_LEFT
	IMPORT BULLET_GAMEOVER
	IMPORT NEON_CAR_MAIN_FRONT
	IMPORT NEON_CAR_MAIN_RIGHT
	IMPORT NEON_CAR_MAIN_LEFT
	IMPORT NEON_CAR_MAIN_DOWN
	IMPORT NEON_CAR_COMP_FRONT
	IMPORT NEON_CAR_COMP_RIGHT
	IMPORT NEON_CAR_COMP_LEFT
	IMPORT NEON_CAR_COMP_DOWN
	IMPORT TRAILS_HORIZONTAL_X
	IMPORT TRAILS_HORIZONTAL_Y
	IMPORT TRAILS_VERTICAL_X
	IMPORT TRAILS_VERTICAL_Y
	IMPORT NEON_BARRAGE
	IMPORT PRESENTS
	IMPORT BULLET_BARRAGE
	IMPORT NEON_CYCLES
	IMPORT ARROW
	IMPORT SPIDERLEFT
	IMPORT SPIDERRIGHT
	EXPORT DELAY_1_MILLI_SEC
	EXPORT DELAY_10_MILLI_SEC
	EXPORT DELAY_100_MILLI_SEC
	EXPORT DELAY_1_SEC
	EXPORT DELAY_10_SEC
	
	

	AREA	MYCODE, CODE, READONLY
	ENTRY
	
__main FUNCTION

	;This is the main funcion, you should only call two functions, one that sets up the TFT
	;And the other that draws a rectangle over the entire screen (ie from (0,0) to (320,240)) with a certain color of your choice


BIGLOOP
	BL SETUP
	LDR R0,=GAMEOVERFLAG
	B SKIP_THIS_LINE7
	LTORG
SKIP_THIS_LINE7
	MOV R1,#0
	STR R1,[R0]	
;SELECT UP FOR BULLET BARRAGE
	;SELECT DOWN FOR NEON CYCLES
	BL START_SCREEN
	LDR R0, =GPIOB_IDR
	LDR R1, [R0]
	AND R1, R1, #0x4000
	CMP R1, #0
	BEQ BBGAMESTART
	LDR R1, [R0]
	AND R1, R1, #0x2000
	CMP R1, #0
	BEQ NEONCYCLESSTART
	B BIGLOOP
	
BBGAMESTART
	MOV R0, #160
	MOV R1, #140
	MOV R3, R1
;	ADD R1, R0, #38
;	ADD R4, R3, #46 ;I KNOW THE HEIGHT IS MORE THAN THE IMAGE, BUT THE EXTRA HEIGHT IS JUST A SAFE MEASURE TO AVOID OVERLAPPING, THE WIDTH SHOULD STRICTLY BE THE SAME AS YOUR PICTURE.

	ADD R1, R0, #14
	ADD R4, R3, #16 ;I KNOW THE HEIGHT IS MORE THAN THE IMAGE, BUT THE EXTRA HEIGHT IS JUST A SAFE MEASURE TO AVOID OVERLAPPING, THE WIDTH SHOULD STRICTLY BE THE SAME AS YOUR PICTURE.

	BL ADDRESS_SET

	MOV R7, #240 ;AREA OF THE PHOTO, 39 X 47
	LDR R5, =ARROW

	;MEMORY WRITE
	MOV R2, #0x2C
	BL LCD_COMMAND_WRITE
IMAGE_LOOP_70
	LDR R6, [R5], #2	;POST INCREMENT
	MOV R2, R6
	BL LCD_16_DATA_WRITE
	SUB R7, R7, #1
	CMP R7, #0
	BGT IMAGE_LOOP_70 
	 BL LOCATION_INIT
	 BL	BULLET_BG
;	 
	 BL DRAW_BULLET_CHAR_D
	 
	MOV R1,#0
	LDR R5,=ISSHOT
	STR R1,[R5]

	MOV R3,#0
	B SKIP81Y4KFJFF
	LTORG
SKIP81Y4KFJFF
LEVEL3INITLOOP
	LDR R5,=NEXT_BULLET
	MOV R0,#138
	MOV R2,#32
	MUL R2,R2,R3
	ADD R0,R0,R2
	MOV R6,#4
	MUL R6,R6,R3
	ADD R5,R5,R6
	STR R0,[R5]
	ADD R3,R3,#1
	CMP R3,#7
	BNE LEVEL3INITLOOP
    LDR R1,=NEXT_BULLET_INDEX
	MOV R2,#0
	STR R2,[R1]
	BL INITIALIZE_SPIDER_VALUES
	BL DRAW_SPIDER1_RIGHT
	;BL DRAW_SPIDER2_LEFT
	;BL DRAW_SPIDER3_RIGHT
;	 BL BULLET_BG

BBGAMELOOP
	 BL COLLISION_W_CHAR
	 BL COLLISION_W_CHAR_S1
	 ;BL COLLISION_W_CHAR_S2
	 ;BL COLLISION_W_CHAR_S3
	 BL MOVE_RIGHT
	 BL MOVE_LEFT
	 BL MOVE_UP
	 BL MOVE_DOWN
	 BL SPAWN_SPIDER1
	 ;BL SPAWN_SPIDER2
	 ;BL SPAWN_SPIDER3
	 LDR R1,=NEXT_BULLET_INDEX
	 LDR R1,[R1]
	 LDR R2,=NEXT_BULLET
	 MOV R6,#4
	 MUL R1,R1,R6
     ADD R2,R2,R1
     LDR R0,[R2]	 
	 BL SPAWN_BULLET	
	 BL MOVE_BULLET_DOWN
	 B SKIP81Y4KFJFFGC   
	LTORG
SKIP81Y4KFJFFGC
	 LDR R0,=GAMEOVERFLAG
	 LDR R0,[R0]
	 CMP R0,#1
	 BEQ BIGLOOP
	 B BBGAMELOOP
	 B BBGAMESTART 
	 
NEONCYCLESSTART
	MOV R0, #160
	MOV R1, #166
	MOV R3, R1
;	ADD R1, R0, #38
;	ADD R4, R3, #46 ;I KNOW THE HEIGHT IS MORE THAN THE IMAGE, BUT THE EXTRA HEIGHT IS JUST A SAFE MEASURE TO AVOID OVERLAPPING, THE WIDTH SHOULD STRICTLY BE THE SAME AS YOUR PICTURE.

	ADD R1, R0, #14
	ADD R4, R3, #16 ;I KNOW THE HEIGHT IS MORE THAN THE IMAGE, BUT THE EXTRA HEIGHT IS JUST A SAFE MEASURE TO AVOID OVERLAPPING, THE WIDTH SHOULD STRICTLY BE THE SAME AS YOUR PICTURE.

	BL ADDRESS_SET

	MOV R7, #240 ;AREA OF THE PHOTO, 39 X 47
	LDR R5, =ARROW

	;MEMORY WRITE
	MOV R2, #0x2C
	BL LCD_COMMAND_WRITE
IMAGE_LOOP_71
	LDR R6, [R5], #2	;POST INCREMENT
	MOV R2, R6
	BL LCD_16_DATA_WRITE
	SUB R7, R7, #1
	CMP R7, #0
	BGT IMAGE_LOOP_71
	

NEONCYCLESLOOP		
	 BL INITIALIZE_ARRAYS
	
	 BL START

     B NEONCYCLESLOOP
	 B BIGLOOP
	ENDFUNC











;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ FUNCTIONS' DEFINITIONS @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
;#####################################################################################################################################################################
START_SCREEN FUNCTION
	PUSH {R0-R10, LR}
	MOV R0, #0
	MOV R1, #0
	MOV R3, #480
	MOV R4, #320
	MOV R10, #0x0000
	BL DRAW_RECTANGLE_FILLED_A
	 
	MOV R0, #180
	MOV R1, #140
	MOV R3, R1
;	ADD R1, R0, #38
;	ADD R4, R3, #46 ;I KNOW THE HEIGHT IS MORE THAN THE IMAGE, BUT THE EXTRA HEIGHT IS JUST A SAFE MEASURE TO AVOID OVERLAPPING, THE WIDTH SHOULD STRICTLY BE THE SAME AS YOUR PICTURE.

	ADD R1, R0, #120
	ADD R4, R3, #14 ;I KNOW THE HEIGHT IS MORE THAN THE IMAGE, BUT THE EXTRA HEIGHT IS JUST A SAFE MEASURE TO AVOID OVERLAPPING, THE WIDTH SHOULD STRICTLY BE THE SAME AS YOUR PICTURE.

	BL ADDRESS_SET

	MOV R7, #1680 ;AREA OF THE PHOTO, 39 X 47
	LDR R5, =NEON_BARRAGE

	;MEMORY WRITE
	MOV R2, #0x2C
	BL LCD_COMMAND_WRITE
IMAGE_LOOP_4
	LDR R6, [R5], #2	;POST INCREMENT
	MOV R2, R6
	BL LCD_16_DATA_WRITE
	SUB R7, R7, #1
	CMP R7, #0
	BGT IMAGE_LOOP_4
	
	MOV R0, #195
	MOV R1, #166
	MOV R3, R1
;	ADD R1, R0, #38
;	ADD R4, R3, #46 ;I KNOW THE HEIGHT IS MORE THAN THE IMAGE, BUT THE EXTRA HEIGHT IS JUST A SAFE MEASURE TO AVOID OVERLAPPING, THE WIDTH SHOULD STRICTLY BE THE SAME AS YOUR PICTURE.

	ADD R1, R0, #88
	ADD R4, R3, #14 ;I KNOW THE HEIGHT IS MORE THAN THE IMAGE, BUT THE EXTRA HEIGHT IS JUST A SAFE MEASURE TO AVOID OVERLAPPING, THE WIDTH SHOULD STRICTLY BE THE SAME AS YOUR PICTURE.

	BL ADDRESS_SET

	MOV R7, #1246 ;AREA OF THE PHOTO, 39 X 47
	LDR R5, =PRESENTS
	
	B SKIP_THIS_LINE70
	LTORG
SKIP_THIS_LINE70

	;MEMORY WRITE
	MOV R2, #0x2C
	BL LCD_COMMAND_WRITE
IMAGE_LOOP_5
	LDR R6, [R5], #2	;POST INCREMENT
	MOV R2, R6
	BL LCD_16_DATA_WRITE
	SUB R7, R7, #1
	CMP R7, #0
	BGT IMAGE_LOOP_5
	
	BL DELAY_1_SEC
	BL DELAY_1_SEC
	
	MOV R0, #0
	MOV R1, #0
	MOV R3, #480
	MOV R4, #320
	MOV R10, #0x0000
	BL DRAW_RECTANGLE_FILLED_A
	
	
	
	MOV R0, #180
	MOV R1, #140
	MOV R3, R1
;	ADD R1, R0, #38
;	ADD R4, R3, #46 ;I KNOW THE HEIGHT IS MORE THAN THE IMAGE, BUT THE EXTRA HEIGHT IS JUST A SAFE MEASURE TO AVOID OVERLAPPING, THE WIDTH SHOULD STRICTLY BE THE SAME AS YOUR PICTURE.

	ADD R1, R0, #142
	ADD R4, R3, #14 ;I KNOW THE HEIGHT IS MORE THAN THE IMAGE, BUT THE EXTRA HEIGHT IS JUST A SAFE MEASURE TO AVOID OVERLAPPING, THE WIDTH SHOULD STRICTLY BE THE SAME AS YOUR PICTURE.

	BL ADDRESS_SET

	MOV R7, #2002 ;AREA OF THE PHOTO, 39 X 47
	LDR R5, =BULLET_BARRAGE

	;MEMORY WRITE
	MOV R2, #0x2C
	BL LCD_COMMAND_WRITE
IMAGE_LOOP_7
	LDR R6, [R5], #2	;POST INCREMENT
	MOV R2, R6
	BL LCD_16_DATA_WRITE
	SUB R7, R7, #1
	CMP R7, #0
	BGT IMAGE_LOOP_7
	
	MOV R0, #180
	MOV R1, #166
	MOV R3, R1
;	ADD R1, R0, #38
;	ADD R4, R3, #46 ;I KNOW THE HEIGHT IS MORE THAN THE IMAGE, BUT THE EXTRA HEIGHT IS JUST A SAFE MEASURE TO AVOID OVERLAPPING, THE WIDTH SHOULD STRICTLY BE THE SAME AS YOUR PICTURE.

	ADD R1, R0, #110
	ADD R4, R3, #14 ;I KNOW THE HEIGHT IS MORE THAN THE IMAGE, BUT THE EXTRA HEIGHT IS JUST A SAFE MEASURE TO AVOID OVERLAPPING, THE WIDTH SHOULD STRICTLY BE THE SAME AS YOUR PICTURE.

	BL ADDRESS_SET

	MOV R7, #1554 ;AREA OF THE PHOTO, 39 X 47
	LDR R5, =NEON_CYCLES

	;MEMORY WRITE
	MOV R2, #0x2C
	BL LCD_COMMAND_WRITE
IMAGE_LOOP_6
	LDR R6, [R5], #2	;POST INCREMENT
	MOV R2, R6
	BL LCD_16_DATA_WRITE
	SUB R7, R7, #1
	CMP R7, #0
	BGT IMAGE_LOOP_6
	B SKIP_THIS_LINE80
	LTORG
SKIP_THIS_LINE80
	 
	
	POP {R0-R10, PC}
	ENDFUNC
;#####################################################################################################################################################################
INITIALIZE_SPIDER_VALUES	FUNCTION
	PUSH{R0-R12, LR}
	EOR R7,R7
	MOV R6,#160
	MOV R8,#130
	LDR R1,=SPIDER1_X
	STRH R6,[R1]
	LDR R2,=SPIDER1_Y 
	STRH R8,[R2]
	LDR R1,=SPIDER2_X
	MOV R6,#128
	STRH R6,[R1]
	MOV R8,#160
	LDR R2,=SPIDER2_Y 
	STRH R8,[R2]
	LDR R1,=SPIDER3_X
	MOV R6,#140
	STRH R6,[R1]
	MOV R8,#190
	LDR R2,=SPIDER3_Y 
	STRH R8,[R2]
	LDR R3,=FLAGSPIDER
	MOV R6,#0
	STRH R6,[R3]
	LDR R4,=FLAGSPIDER2
	MOV R9,#1
	STRH R9,[R4]
	LDR R5,=FLAGSPIDER3
	MOV R6,#0
	STRH R6,[R5]
	POP {R0-R12, PC}
	ENDFUNC
	
DRAW_SPIDER1_LEFT	FUNCTION
	;THIS FUNCTION TAKES STARTING X AND STARTING Y THEN DRAWS AN IMAGE
	;ARGUMENTS: R0 = X, R1 = Y
	PUSH{R0-R12, LR}
	
	LDR R8, =SPIDER1_X
	;LDR R7, =SPIDER1_Y
	
	LDR R0, [R8]
	;LDR R1, [R7]
	
	MOV R1,#130
	ADD R5, R0, #29
	ADD R6, R1, #14
	LDR R11, =SPIDERLEFT
	LDRH R10, [R11]
	MOV R4, #0xFF
	LSL R4, #8
	ADD R4, R4, #0xFE
	
LOOP_SPIDER1_LEFT_Y
	LDR R0, [R8]
	SUB R0, R0, #1
LOOP_SPIDER1_LEFT_X
	CMP R10, R4
	BEQ LOOP_SPIDER1_LEFT
	BL DRAWPIXEL
LOOP_SPIDER1_LEFT
	ADD R0, R0, #1
	LDRH R10, [R11], #2
	CMP R0, R5
	BNE LOOP_SPIDER1_LEFT_X
	ADD R1, R1, #1
	CMP R1, R6
	BNE LOOP_SPIDER1_LEFT_Y
	;LDR R8, =SPIDER1_X
	;STR R0,[R8]
	POP {R0-R12, PC}

	ENDFUNC

DRAW_SPIDER2_LEFT	FUNCTION
		;THIS FUNCTION TAKES STARTING X AND STARTING Y THEN DRAWS AN IMAGE
	;ARGUMENTS: R0 = X, R1 = Y
	PUSH{R0-R12, LR}
	
	LDR R8, =SPIDER2_X
	;LDR R7, =SPIDER1_Y
	
	LDR R0, [R8]
	;LDR R1, [R7]
	
	MOV R1,#160
	ADD R5, R0, #29
	ADD R6, R1, #14
	LDR R11, =SPIDERLEFT
	LDRH R10, [R11]
	MOV R4, #0xFF
	LSL R4, #8
	ADD R4, R4, #0xFE
	
LOOP_SPIDER2_LEFT_Y
	LDR R0, [R8]
	SUB R0, R0, #1
LOOP_SPIDER2_LEFT_X
	CMP R10, R4
	BEQ LOOP_SPIDER2_LEFT
	BL DRAWPIXEL
LOOP_SPIDER2_LEFT
	ADD R0, R0, #1
	LDRH R10, [R11], #2
	CMP R0, R5
	BNE LOOP_SPIDER2_LEFT_X
	ADD R1, R1, #1
	CMP R1, R6
	BNE LOOP_SPIDER2_LEFT_Y
	;LDR R8, =SPIDER1_X
	;STR R0,[R8]
	POP {R0-R12, PC}

	ENDFUNC

DRAW_SPIDER3_LEFT	FUNCTION
	;THIS FUNCTION TAKES STARTING X AND STARTING Y THEN DRAWS AN IMAGE
	;ARGUMENTS: R0 = X, R1 = Y
	PUSH{R0-R12, LR}
	
	LDR R8, =SPIDER3_X
	;LDR R7, =SPIDER1_Y
	
	LDR R0, [R8]
	;LDR R1, [R7]
	
	MOV R1,#190
	ADD R5, R0, #29
	ADD R6, R1, #14
	LDR R11, =SPIDERLEFT
	LDRH R10, [R11]
	MOV R4, #0xFF
	LSL R4, #8
	ADD R4, R4, #0xFE
	
LOOP_SPIDER3_LEFT_Y
	LDR R0, [R8]
	SUB R0, R0, #1
LOOP_SPIDER3_LEFT_X
	CMP R10, R4
	BEQ LOOP_SPIDER3_LEFT
	BL DRAWPIXEL
LOOP_SPIDER3_LEFT
	ADD R0, R0, #1
	LDRH R10, [R11], #2
	CMP R0, R5
	BNE LOOP_SPIDER3_LEFT_X
	ADD R1, R1, #1
	CMP R1, R6
	BNE LOOP_SPIDER3_LEFT_Y
	;LDR R8, =SPIDER1_X
	;STR R0,[R8]
	POP {R0-R12, PC}

	ENDFUNC	

DRAW_SPIDER1_RIGHT	FUNCTION
	;THIS FUNCTION TAKES STARTING X AND STARTING Y THEN DRAWS AN IMAGE
	;ARGUMENTS: R0 = X, R1 = Y
	PUSH{R0-R12, LR}
	
	LDR R8, =SPIDER1_X
	;LDR R7, =SPIDER1_Y
	
	LDR R0, [R8]
	;LDR R1, [R7]
	
	MOV R1,#130
	ADD R5, R0, #29
	ADD R6, R1, #14
	LDR R11, =SPIDERRIGHT
	LDRH R10, [R11]
	MOV R4, #0xFF
	LSL R4, #8
	ADD R4, R4, #0xFE
	
LOOP_SPIDER1_RIGHT_Y
	LDR R0, [R8]
	SUB R0, R0, #1
LOOP_SPIDER1_RIGHT_X
	CMP R10, R4
	BEQ LOOP_SPIDER1_RIGHT
	BL DRAWPIXEL
LOOP_SPIDER1_RIGHT
	ADD R0, R0, #1
	LDRH R10, [R11], #2
	CMP R0, R5
	BNE LOOP_SPIDER1_RIGHT_X
	ADD R1, R1, #1
	CMP R1, R6
	BNE LOOP_SPIDER1_RIGHT_Y
	;LDR R8, =SPIDER1_X
	;STR R0,[R8]
	POP {R0-R12, PC}

	ENDFUNC

DRAW_SPIDER2_RIGHT	FUNCTION
	;THIS FUNCTION TAKES STARTING X AND STARTING Y THEN DRAWS AN IMAGE
	;ARGUMENTS: R0 = X, R1 = Y
	PUSH{R0-R12, LR}
	
	LDR R8, =SPIDER2_X
	;LDR R7, =SPIDER1_Y
	
	LDR R0, [R8]
	;LDR R1, [R7]
	
	MOV R1,#160
	ADD R5, R0, #29
	ADD R6, R1, #14
	LDR R11, =SPIDERRIGHT
	LDRH R10, [R11]
	MOV R4, #0xFF
	LSL R4, #8
	ADD R4, R4, #0xFE
	
LOOP_SPIDER2_RIGHT_Y
	LDR R0, [R8]
	SUB R0, R0, #1
LOOP_SPIDER2_RIGHT_X
	CMP R10, R4
	BEQ LOOP_SPIDER2_RIGHT
	BL DRAWPIXEL
LOOP_SPIDER2_RIGHT
	ADD R0, R0, #1
	LDRH R10, [R11], #2
	CMP R0, R5
	BNE LOOP_SPIDER2_RIGHT_X
	ADD R1, R1, #1
	CMP R1, R6
	BNE LOOP_SPIDER2_RIGHT_Y
	;LDR R8, =SPIDER1_X
	;STR R0,[R8]
	POP {R0-R12, PC}
	ENDFUNC

DRAW_SPIDER3_RIGHT	FUNCTION
	;THIS FUNCTION TAKES STARTING X AND STARTING Y THEN DRAWS AN IMAGE
	;ARGUMENTS: R0 = X, R1 = Y
	PUSH{R0-R12, LR}
	
	LDR R8, =SPIDER3_X
	;LDR R7, =SPIDER1_Y
	
	LDR R0, [R8]
	;LDR R1, [R7]
	
	MOV R1,#190
	ADD R5, R0, #29
	ADD R6, R1, #14
	LDR R11, =SPIDERRIGHT
	LDRH R10, [R11]
	MOV R4, #0xFF
	LSL R4, #8
	ADD R4, R4, #0xFE
	
LOOP_SPIDER3_RIGHT_Y
	LDR R0, [R8]
	SUB R0, R0, #1
LOOP_SPIDER3_RIGHT_X
	CMP R10, R4
	BEQ LOOP_SPIDER3_RIGHT
	BL DRAWPIXEL
LOOP_SPIDER3_RIGHT
	ADD R0, R0, #1
	LDRH R10, [R11], #2
	CMP R0, R5
	BNE LOOP_SPIDER3_RIGHT_X
	ADD R1, R1, #1
	CMP R1, R6
	BNE LOOP_SPIDER3_RIGHT_Y
	;LDR R8, =SPIDER1_X
	;STR R0,[R8]
	POP {R0-R12, PC}

	ENDFUNC

MOVE_SPIDER1_RIGHT FUNCTION
	PUSH {R0-R12, LR}
	LDR R5, =SPIDER1_X
	LDR R0, [R5]
	BL RESET_SPIDER1_BG
	ADD R0, #16
	STR R0,[R5]
	BL DRAW_SPIDER1_RIGHT
	POP {R0-R12, PC}
	ENDFUNC

MOVE_SPIDER2_RIGHT FUNCTION
	PUSH {R0-R12, LR}
	LDR R5, =SPIDER2_X
	LDR R0, [R5]
	BL RESET_SPIDER2_BG
	ADD R0, #31
	STR R0,[R5]
	BL DRAW_SPIDER2_RIGHT
	POP {R0-R12, PC}
	ENDFUNC
MOVE_SPIDER3_RIGHT FUNCTION
	PUSH {R0-R12, LR}
	LDR R5, =SPIDER3_X
	LDR R0, [R5]
	BL RESET_SPIDER3_BG
	ADD R0, #31
	STR R0,[R5]
	BL DRAW_SPIDER3_RIGHT
	POP {R0-R12, PC}
	ENDFUNC

MOVE_SPIDER1_LEFT FUNCTION
	PUSH {R0-R12, LR}
	LDR R5, =SPIDER1_X
	LDR R0, [R5]
	BL RESET_SPIDER1_BG
	SUB R0, #16
	STR R0,[R5]
	BL DRAW_SPIDER1_LEFT
	POP {R0-R12, PC}
	ENDFUNC
MOVE_SPIDER2_LEFT FUNCTION
	PUSH {R0-R12, LR}
	LDR R5, =SPIDER2_X
	LDR R0, [R5]
	BL RESET_SPIDER2_BG
	SUB R0, #31
	STR R0,[R5]
	BL DRAW_SPIDER2_LEFT
	POP {R0-R12, PC}
	ENDFUNC
MOVE_SPIDER3_LEFT FUNCTION
	PUSH {R0-R12, LR}
	LDR R5, =SPIDER3_X
	LDR R0, [R5]
	BL RESET_SPIDER3_BG
	SUB R0, #31
	STR R0,[R5]
	BL DRAW_SPIDER3_LEFT
	POP {R0-R12, PC}
	ENDFUNC

RESET_SPIDER1_BG FUNCTION
	PUSH {R0-R11, LR}
	LDR R3, =SPIDER1_X
	LDR R4, =SPIDER1_Y
	MOV R10,#1 ;SAME X TILE
	MOV R11,#1 ;SAME Y TILE
	LDRH R6,[R3] ;Bullet X Cords
	MOV R7,#130 ;Bullet Y Cords
	MOV R5,#32
	;TOP LEFT TILE
	UDIV R0,R6,R5 ; X Index
	UDIV R1,R7,R5 ; Y Index
	MUL  R0,R0,R5 ; X Axis
	MUL  R1,R1,R5 ; Y Axis
	BL DRAW_ROAD
	;BOTTOM LEFT TILE
	ADD R9,R7,#13 ;HEIGHT-1
	UDIV R9,R9,R5 ; Y Index
	MUL  R9,R9,R5 ; Y Axis
	CMP R9,R1
	BEQ SAMETILEON_Y
	MOV R10,#0
	MOV R1,R9
	BL DRAW_ROAD	
SAMETILEON_Y
	;TOP RIGHT CHECK
	UDIV R0,R6,R5
	MUL  R0,R0,R5 ; X Axis
	ADD R9,R6,#29 ;width-1
	UDIV R9,R9,R5
	MUL R9,R9,R5
	CMP R0,R9
	BEQ SAMETILEON_X
	MOV R11,#0
	MOV R0,R9
	MOV R1,R7
	BL DRAW_ROAD
SAMETILEON_X
	CMP R10,#1
	BNE NAH
	CMP R11,#1
	BNE NAH
	ADD R0,R6,#29 ;WIDTH-1
	ADD R1,R7,#13;HEIGHT-1
	UDIV R0,R0,R5 ; X Index
	UDIV R1,R1,R5 ; Y Index
	MUL  R0,R0,R5 ; X Axis
	MUL  R1,R1,R5 ; Y Axis
	BL DRAW_ROAD
NAH	
	POP {R0-R11, PC}
	ENDFUNC

RESET_SPIDER2_BG FUNCTION
	PUSH {R0-R11, LR}
	LDR R3, =SPIDER2_X
	LDR R4, =SPIDER2_Y
	B KICKMAN3
	LTORG
KICKMAN3
	MOV R10,#1 ;SAME X TILE
	MOV R11,#1 ;SAME Y TILE
	LDRH R6,[R3] ;Bullet X Cords
	MOV R7,#160 ;Bullet Y Cords
	MOV R5,#32
	;TOP LEFT TILE
	UDIV R0,R6,R5 ; X Index
	UDIV R1,R7,R5 ; Y Index
	MUL  R0,R0,R5 ; X Axis
	MUL  R1,R1,R5 ; Y Axis
	BL DRAW_ROAD
	;BOTTOM LEFT TILE
	ADD R9,R7,#13 ;HEIGHT-1
	UDIV R9,R9,R5 ; Y Index
	MUL  R9,R9,R5 ; Y Axis
	CMP R9,R1
	BEQ SAMETILEON_Y2
	MOV R10,#0
	MOV R1,R9
	BL DRAW_ROAD	
SAMETILEON_Y2
	;TOP RIGHT CHECK
	UDIV R0,R6,R5
	MUL  R0,R0,R5 ; X Axis
	ADD R9,R6,#29 ;width-1
	UDIV R9,R9,R5
	MUL R9,R9,R5
	CMP R0,R9
	BEQ SAMETILEON_X2
	MOV R11,#0
	MOV R0,R9
	MOV R1,R7
	BL DRAW_ROAD
SAMETILEON_X2
	CMP R10,#1
	BNE NAH2
	CMP R11,#1
	BNE NAH2
	ADD R0,R6,#29 ;WIDTH-1
	ADD R1,R7,#13;HEIGHT-1
	UDIV R0,R0,R5 ; X Index
	UDIV R1,R1,R5 ; Y Index
	MUL  R0,R0,R5 ; X Axis
	MUL  R1,R1,R5 ; Y Axis
	BL DRAW_ROAD
NAH2
	POP {R0-R11, PC}
	ENDFUNC
RESET_SPIDER3_BG FUNCTION
	PUSH {R0-R11, LR}
	LDR R3, =SPIDER3_X
	LDR R4, =SPIDER3_Y
	MOV R10,#1 ;SAME X TILE
	MOV R11,#1 ;SAME Y TILE
	LDRH R6,[R3] ;Bullet X Cords
	MOV R7,#190 ;Bullet Y Cords
	MOV R5,#32
	;TOP LEFT TILE
	UDIV R0,R6,R5 ; X Index
	UDIV R1,R7,R5 ; Y Index
	MUL  R0,R0,R5 ; X Axis
	MUL  R1,R1,R5 ; Y Axis
	BL DRAW_ROAD
	;BOTTOM LEFT TILE
	ADD R9,R7,#13 ;HEIGHT-1
	UDIV R9,R9,R5 ; Y Index
	MUL  R9,R9,R5 ; Y Axis
	CMP R9,R1
	BEQ SAMETILEON_Y3
	MOV R10,#0
	MOV R1,R9
	BL DRAW_ROAD	
SAMETILEON_Y3
	;TOP RIGHT CHECK
	UDIV R0,R6,R5
	MUL  R0,R0,R5 ; X Axis
	ADD R9,R6,#29 ;width-1
	UDIV R9,R9,R5
	MUL R9,R9,R5
	CMP R0,R9
	BEQ SAMETILEON_X3
	MOV R11,#0
	MOV R0,R9
	MOV R1,R7
	BL DRAW_ROAD
SAMETILEON_X3
	CMP R10,#1
	BNE NAH3
	CMP R11,#1
	BNE NAH3
	ADD R0,R6,#29 ;WIDTH-1
	ADD R1,R7,#13;HEIGHT-1
	UDIV R0,R0,R5 ; X Index
	UDIV R1,R1,R5 ; Y Index
	MUL  R0,R0,R5 ; X Axis
	MUL  R1,R1,R5 ; Y Axis
	BL DRAW_ROAD
NAH3
	POP {R0-R11, PC}
	ENDFUNC

SPAWN_SPIDER1 FUNCTION
	 PUSH {R0-R12, LR}
	 LDR R5, =SPIDER1_X
	 LDRH R6,[R5]
	 LDR R7,=FLAGSPIDER
	 LDRH R8,[R7]
	 CMP R8,#1
	 BEQ SPIDER1LEFT
SPIDER1RIGHT
	 CMP R6,#446
	 BLE INRIGHTLIMIT
	 MOV R8,#1
	 STR R8,[R7]
	 B DIESPIDERMAN1
INRIGHTLIMIT
	 LDR R9,=SPRITE_X
	 LDR R10,[R9]
	 LDR R11,=SPRITE_Y
	 LDR R0,[R11]
	 CMP R0,#130
	 BLT FOLLOWCHARSP1
	 BL MOVE_SPIDER1_RIGHT
	 B DIESPIDERMAN1
SPIDER1LEFT
	 CMP R6,#2
	 BGE INLIMITLEFT
	 MOV R8,#0
	 STR R8,[R7]
	 B DIESPIDERMAN1
INLIMITLEFT
	 LDR R9,=SPRITE_X
	 LDR R10,[R9]
	 LDR R11,=SPRITE_Y
	 LDR R0,[R11]
	 CMP R0,#130
	 BLT FOLLOWCHARSP1
	 BL MOVE_SPIDER1_LEFT
	 B DIESPIDERMAN1
FOLLOWCHARSP1
	 CMP R10,R6
	 BGT CHANGEDIRTORIGHT
	 BLT CHANGEDIRTOLEFT
	 BEQ DIESPIDERMAN1
CHANGEDIRTORIGHT
	 MOV R1,#0
	 STR R1,[R7]
	 BL MOVE_SPIDER1_RIGHT
	 B DIESPIDERMAN1
CHANGEDIRTOLEFT
	 MOV R1,#1
	 STR R1,[R7]
	 BL MOVE_SPIDER1_LEFT
	 B DIESPIDERMAN1
DIESPIDERMAN1
 	 POP {R0-R12, PC}
	 ENDFUNC
	 
SPAWN_SPIDER2 FUNCTION
	 PUSH {R0-R12, LR}
	 LDR R5, =SPIDER2_X
	 LDRH R6,[R5]
	 LDR R7,=FLAGSPIDER2
	 LDRH R8,[R7]
	 CMP R8,#1
	 BEQ SPIDER2LEFT
SPIDER2RIGHT
	 CMP R6,#390
	 BLE INRIGHTLIMIT2
	 MOV R8,#1
	 STR R8,[R7]
	 B DIESPIDERMAN2
INRIGHTLIMIT2
	 BL MOVE_SPIDER2_RIGHT
	 B DIESPIDERMAN2
SPIDER2LEFT
	 CMP R6,#2
	 BGE INLIMITLEFT2
	 MOV R8,#0
	 STR R8,[R7]
	 B DIESPIDERMAN2
INLIMITLEFT2
	 BL MOVE_SPIDER2_LEFT
	 B DIESPIDERMAN2
DIESPIDERMAN2
 	 POP {R0-R12, PC}
	 ENDFUNC
	 
SPAWN_SPIDER3 FUNCTION
	 PUSH {R0-R12, LR}
	 MOV R0,#190
	 LDR R5, =SPIDER3_X
	 LDRH R6,[R5]
	 LDR R7,=FLAGSPIDER3
	B SKIP_THIS_PLEASE
	LTORG
SKIP_THIS_PLEASE	 
	 LDRH R8,[R7]
	 CMP R8,#1
	 BEQ SPIDER3LEFT
SPIDER3RIGHT
	 CMP R6,#390
	 BLE INRIGHTLIMIT3
	 MOV R8,#1
	 STR R8,[R7]
	 B DIESPIDERMAN3
INRIGHTLIMIT3
	 BL MOVE_SPIDER3_RIGHT
	 B DIESPIDERMAN3
SPIDER3LEFT
	 CMP R6,#2
	 BGE INLIMITLEFT3
	 MOV R8,#0
	 STR R8,[R7]
	 B DIESPIDERMAN3
INLIMITLEFT3
	 BL MOVE_SPIDER3_LEFT
	 B DIESPIDERMAN3
DIESPIDERMAN3
 	 POP {R0-R12, PC}
	 ENDFUNC


;#####################################################################################################################################################################


INITIALIZE_ARRAYS FUNCTION
	PUSH {R0-R2, LR}

	LDR 	R0, =HORIZONTAL_TRAIL_COUNT
	MOV 	R1, #0
	STRH	R1, [R0] ;Initiallize the horizontal count with 0
	
	LDR 	R0, =VERTICAL_TRAIL_COUNT
	MOV 	R1, #0
	STRH	R1, [R0] ;Initiallize the vertical count with 0
	
	
	LDR R0, =TRAILS_HORIZONTAL_X
	MOV	R1, #0
	MOV R2, #0XFFFF
INIT_LOOP1 ;this loop initalizes the Trails_horizontal_x array with 0xffff
	STRH	R2, [R0], #2
	ADD R1, R1, #1
	CMP R1, #288 ;100 is the size of the array
	BNE INIT_LOOP1
	
	
	LDR R0, =TRAILS_HORIZONTAL_Y
	MOV	R1, #0
INIT_LOOP2 ;this loop initalizes the Trails_horizontal_y array with 0xffff
	LDRH	R2, [R0], #2
	ADD R1, R1, #1
	CMP R1, #288
	BNE INIT_LOOP2
	
	LDR R0, =TRAILS_VERTICAL_X
	MOV	R1, #0
INIT_LOOP3 ;this loop initalizes the Trails_vertical_x array with 0xffff
	LDRH	R2, [R0], #2
	ADD R1, R1, #1
	CMP R1, #288
	BNE INIT_LOOP3
	
	LDR R0, =TRAILS_VERTICAL_Y
	MOV	R1, #0
INIT_LOOP4 ;this loop initalizes the Trails_vertical_y array with 0xffff
	LDRH	R2, [R0], #2
	ADD R1, R1, #1
	CMP R1, #288
	BNE INIT_LOOP4
	
	POP {R0-R2, PC}
	ENDFUNC









COLLISION_W_CHAR FUNCTION
 PUSH {R1-R7, lr}         
    
 
    LDR R4, =SPRITE_X     
    LDR R4, [R4]         
    
    LDR R5, =SPRITE_Y     
    LDR R5, [R5]         
    ; Load arguments (x1, y1,x2, y2) into registers R0, R1, R2, R3
    MOV R6, #19
	ADD R6, R6, R4
	MOV R7, #27
	ADD R7,R7,R5

	;(X1,Y1,X2,Y2) 1 -> R4,R5,R6,R7
	LDR R0, =BULLET_X
	LDR R0, [R0]
	LDR R1, =BULLET_Y
	LDR R1, [R1]
	ADD R2, R0, #8
	ADD R3, R1, #16
	;(X1,Y1,X2,Y2) 2 -> R0,R1,R2,R3 
    ; Check for overlap
    CMP R4, R2; RIGHT
    BGT NO 	
    CMP R6, R0 ;LEFT    
    BLT NO          
    CMP R5, R3 ;BELOW          
    BGT NO        
    CMP R7, R1 ;ABOVE          
    BLT NO    
	BL GAMEOVER
NO	
    POP {R1-R7, pc}         
	ENDFUNC
	
	
COLLISION_W_CHAR_S1 FUNCTION
 PUSH {R1-R7, lr}         
    
 
    LDR R4, =SPRITE_X     
    LDR R4, [R4]         
    
    LDR R5, =SPRITE_Y     
    LDR R5, [R5]         
    ; Load arguments (x1, y1,x2, y2) into registers R0, R1, R2, R3
    MOV R6, #19
	ADD R6, R6, R4
	MOV R7, #27
	ADD R7,R7,R5
	B SKIP_THIS_LINEGG
	LTORG
SKIP_THIS_LINEGG
	;(X1,Y1,X2,Y2) 1 -> R4,R5,R6,R7
	LDR R0, =SPIDER1_X
	LDR R0, [R0]
	LDR R1, =SPIDER1_Y
	LDR R1, [R1]
	ADD R2, R0, #30
	ADD R3, R1, #14
	;(X1,Y1,X2,Y2) 2 -> R0,R1,R2,R3 
    ; Check for overlap
    CMP R4, R2; RIGHT
    BGT NO2 	
    CMP R6, R0 ;LEFT    
    BLT NO2          
    CMP R5, R3 ;BELOW          
    BGT NO2        
    CMP R7, R1 ;ABOVE          
    BLT NO2    
	BL GAMEOVER
NO2	
    POP {R1-R7, pc}         
	ENDFUNC	
	
	
COLLISION_W_CHAR_S2 FUNCTION
 PUSH {R1-R7, lr}         
    
 
    LDR R4, =SPRITE_X     
    LDR R4, [R4]         
    
    LDR R5, =SPRITE_Y     
    LDR R5, [R5]         
    ; Load arguments (x1, y1,x2, y2) into registers R0, R1, R2, R3
    MOV R6, #19
	ADD R6, R6, R4
	MOV R7, #27
	ADD R7,R7,R5

	;(X1,Y1,X2,Y2) 1 -> R4,R5,R6,R7
	LDR R0, =SPIDER2_X
	LDR R0, [R0]
	LDR R1, =SPIDER2_Y
	LDR R1, [R1]
	ADD R2, R0, #30
	ADD R3, R1, #14
	;(X1,Y1,X2,Y2) 2 -> R0,R1,R2,R3 
    ; Check for overlap
    CMP R4, R2; RIGHT
    BGT NO3 	
    CMP R6, R0 ;LEFT    
    BLT NO3          
    CMP R5, R3 ;BELOW          
    BGT NO3        
    CMP R7, R1 ;ABOVE          
    BLT NO3    
	BL GAMEOVER
NO3	
    POP {R1-R7, pc}         
	ENDFUNC

COLLISION_W_CHAR_S3 FUNCTION
 PUSH {R1-R7, lr}         
    
 
    LDR R4, =SPRITE_X     
    LDR R4, [R4]         
    
    LDR R5, =SPRITE_Y     
    LDR R5, [R5]         
    ; Load arguments (x1, y1,x2, y2) into registers R0, R1, R2, R3
    MOV R6, #19
	ADD R6, R6, R4
	MOV R7, #27
	ADD R7,R7,R5

	;(X1,Y1,X2,Y2) 1 -> R4,R5,R6,R7
	LDR R0, =SPIDER3_X
	LDR R0, [R0]
	LDR R1, =SPIDER3_Y
	LDR R1, [R1]
	ADD R2, R0, #30
	ADD R3, R1, #14
	;(X1,Y1,X2,Y2) 2 -> R0,R1,R2,R3 
    ; Check for overlap
    CMP R4, R2; RIGHT
    BGT NO4 	
    CMP R6, R0 ;LEFT    
    BLT NO4          
    CMP R5, R3 ;BELOW          
    BGT NO4        
    CMP R7, R1 ;ABOVE          
    BLT NO4    
	BL GAMEOVER
NO4	
    POP {R1-R7, pc}         
	ENDFUNC		

;#####################################################################################################################################################################
GAMEOVER FUNCTION
	PUSH {R0-R7, R10, LR}
	
	MOV R0, #0
	MOV R1, #0
	MOV R3, #480
	MOV R4, #320
	MOV R10, #0x0000
	BL DRAW_RECTANGLE_FILLED_A
	
	MOV R0, #194
	MOV R1, #153
	
	MOV R3, R1
	ADD R1, R0, #91
	ADD R4, R3, #14 ;I KNOW THE HEIGHT IS MORE THAN THE IMAGE, BUT THE EXTRA HEIGHT IS JUST A SAFE MEASURE TO AVOID OVERLAPPING, THE WIDTH SHOULD STRICTLY BE THE SAME AS YOUR PICTURE.

	BL ADDRESS_SET

	MOV R7, #1288 ;AREA OF THE PHOTO, 39 X 47
	LDR R5, =BULLET_GAMEOVER

	;MEMORY WRITE
	MOV R2, #0x2C
	BL LCD_COMMAND_WRITE
IMAGE_LOOP_G
	LDR R6, [R5], #2	;POST INCREMENT
	MOV R2, R6
	BL LCD_16_DATA_WRITE
	SUB R7, R7, #1
	CMP R7, #0
	BGT IMAGE_LOOP_G
	
LOOP_END

	B LOOP_END
	LDR R0,=GAMEOVERFLAG
	MOV R1,#1
	STR R1,[R0]
	POP {R0-R7, R10, PC}
	ENDFUNC
;#####################################################################################################################################################################
MOVE_DOWN FUNCTION
	PUSH {R0-R1, LR}
	LDR R0, =RESET_W
	MOV R1, #19
	STRH R1, [R0]
	LDR R0, =RESET_H
	MOV R1, #27
	STRH R1, [R0]

	LDR R0, =SPRITE_X
	LDR R1, [R0]
	LDR R0, =RESET_X
	STR R1, [R0]
	
	LDR R0, =SPRITE_Y
	LDR R1, [R0]
	LDR R0, =RESET_Y
	STR R1, [R0]
	
	LDR R0, =GPIOB_IDR
	LDR R1, [R0]
	AND R1, R1, #0x2000
	CMP R1, #0
	BNE SKIP_DOWN
	LDR R0, =SPRITE_X
	LDR R1, [R0]
	CMP R1, #128
	BLT CASE_2_DOWN
	MOV R0, #0x14
	LSL R0, #4
	ADD R0, #0xD
	CMP R1, R0
	BGE CASE_2_DOWN
	LDR R0, =SPRITE_Y
	LDR R1, [R0]
	CMP R1, #290
	BGE SKIP_DOWN
	BL RESET_CHAR_BG
	ADD R1, R1, #4
	STR R1, [R0]
	BL DRAW_BULLET_CHAR_D
	B SKIP_DOWN
	
	
	
CASE_2_DOWN
	LDR R0, =SPRITE_Y
	LDR R1, [R0]
	CMP R1, #195
	BGT SKIP_DOWN
	BL RESET_CHAR_BG
	ADD R1, R1, #4
	STR R1, [R0]
	BL DRAW_BULLET_CHAR_D
	
SKIP_DOWN
	POP {R0-R1, PC}
	ENDFUNC
;#####################################################################################################################################################################
MOVE_UP FUNCTION
	PUSH {R0-R1, LR}
	LDR R0, =RESET_W
	MOV R1, #19
	STRH R1, [R0]
	LDR R0, =RESET_H
	MOV R1, #27
	STRH R1, [R0]
	
	LDR R0, =SPRITE_X
	LDR R1, [R0]
	LDR R0, =RESET_X
	STR R1, [R0]
	
	LDR R0, =SPRITE_Y
	LDR R1, [R0]
	LDR R0, =RESET_Y
	STR R1, [R0]
	
	LDR R0, =GPIOB_IDR
	LDR R1, [R0]
	AND R1, R1, #0x4000
	CMP R1, #0
	BNE SKIP_UP
	LDR R0, =SPRITE_X
	LDR R1, [R0]
	CMP R1, #128
	BLT CASE_2_UP
	MOV R0, #0x14
	LSL R0, #4
	ADD R0, #0xD
	CMP R1, R0
	BGE CASE_2_UP
	LDR R0, =SPRITE_Y
	LDR R1, [R0]
	CMP R1, #4
	BLE SKIP_UP
	BL RESET_CHAR_BG
	SUB R1, R1, #4
	STR R1, [R0]
	BL DRAW_BULLET_CHAR_U
	B SKIP_UP
	
CASE_2_UP
	LDR R0, =SPRITE_Y
	LDR R1, [R0]
	CMP R1, #96
	BLE SKIP_UP
	BL RESET_CHAR_BG
	SUB R1, R1, #4
	STR R1, [R0]
	BL DRAW_BULLET_CHAR_U
	
SKIP_UP
	POP {R0-R1, PC}
	ENDFUNC
;#####################################################################################################################################################################
MOVE_LEFT FUNCTION
	PUSH {R0-R1, LR}
	LDR R0, =RESET_W
	MOV R1, #19
	STRH R1, [R0]
	LDR R0, =RESET_H
	MOV R1, #27
	STRH R1, [R0]
	
	LDR R0, =SPRITE_X
	LDR R1, [R0]
	LDR R0, =RESET_X
	STR R1, [R0]
	
	LDR R0, =SPRITE_Y
	LDR R1, [R0]
	LDR R0, =RESET_Y
	STR R1, [R0]
	
	LDR R0, =GPIOB_IDR
	LDR R1, [R0]
	AND R1, R1, #0x400
	CMP R1, #0
	BNE SKIP_LEFT
	LDR R0, =SPRITE_Y
	LDR R1, [R0]
	CMP R1, #96
	BLT CASE_2_LEFT
	CMP R1, #197
	BGE CASE_2_LEFT
	LDR R0, =SPRITE_X
	LDR R1, [R0]
	CMP R1, #4
	BLE SKIP_LEFT
	BL RESET_CHAR_BG
	SUB R1, R1, #4
	STR R1, [R0]
	BL DRAW_BULLET_CHAR_L
	B SKIP_LEFT
	
CASE_2_LEFT
	LDR R0, =SPRITE_X
	LDR R1, [R0]
	CMP R1, #132
	BLE SKIP_LEFT
	BL RESET_CHAR_BG
	SUB R1, R1, #4
	STR R1, [R0]
	BL DRAW_BULLET_CHAR_L
	
SKIP_LEFT
	
	POP {R0-R1, PC}
	ENDFUNC
;#####################################################################################################################################################################
MOVE_RIGHT FUNCTION
	PUSH {R0-R1, LR}
	LDR R0, =RESET_W
	MOV R1, #19
	STRH R1, [R0]
	LDR R0, =RESET_H
	MOV R1, #27
	STRH R1, [R0]
	
	LDR R0, =SPRITE_X
	LDR R1, [R0]
	LDR R0, =RESET_X
	STR R1, [R0]
	
	LDR R0, =SPRITE_Y
	LDR R1, [R0]
	LDR R0, =RESET_Y
	STR R1, [R0]
	
	LDR R0, =GPIOB_IDR
	LDR R1, [R0]
	AND R1, R1, #0x1000
	CMP R1, #0
	BNE SKIP_RIGHT
	LDR R0, =SPRITE_Y
	LDR R1, [R0]
	CMP R1, #96
	BLT CASE_2_RIGHT
	CMP R1, #197
	BGE CASE_2_RIGHT
	LDR R0, =SPRITE_X
	LDR R1, [R0]
	CMP R1, #460
	BGE SKIP_RIGHT
	BL RESET_CHAR_BG
	ADD R1, R1, #4
	STR R1, [R0]
	BL DRAW_BULLET_CHAR_R
	B SKIP_RIGHT
	
	
	
CASE_2_RIGHT
	LDR R0, =SPRITE_X
	LDR R1, [R0]
	CMP R1, #0x146
	BGT SKIP_RIGHT
	BL RESET_CHAR_BG
	ADD R1, R1, #4
	LDR R0, =SPRITE_X
	STR R1, [R0]
	BL DRAW_BULLET_CHAR_R
	
SKIP_RIGHT
	POP {R0-R1, PC}
	ENDFUNC
;#####################################################################################################################################################################
RESET_CHAR_BG FUNCTION
	PUSH {R0-R8, LR}
	LDR R0, =TILE_X
	LDR R1, =TILE_Y
	LDR R3, =RESET_X
	LDR R4, =RESET_Y
	LDR R5, [R3]
	LDR R6, [R4]
	MOV R7, #32
	MOV R3, #0
	MOV R4, #0
	
	CMP R5, #32
	BLE SKIP_RESET_1
LOOP_RESET_1
	SUB R5, R5, #32
	ADD R3, R3, #1
	CMP R5, #32
	BGE LOOP_RESET_1	
SKIP_RESET_1
	
	CMP R6, #32
	BLE SKIP_RESET_2
LOOP_RESET_2
	SUB R6, R6, #32
	ADD R4, R4, #1
	CMP R6, #32
	BGE LOOP_RESET_2	
SKIP_RESET_2
	
	MUL R3, R3, R7
	MUL R4, R4, R7
	
	LDR R7, =RESET_W
	LDRH R8, [R7]
	MOV R7, #32
	SUB R8, R7, R8
	SUB R8, R8, #1
	CMP R5, R8
	BGE DRAW_1X2
	LDR R7, =RESET_H
	LDRH R8, [R7]
	MOV R7, #32
	SUB R8, R7, R8
	ADD R8, R8, #1
	CMP R6, R8
	BGE DRAW_2X1
	
	
DRAW_1X1
	STR R3, [R0]
	STR R4, [R1]
	BL DRAW_TILE
	
	B SKIP_RESET_3
DRAW_1X2
	CMP R6, #4
	BGT DRAW_2X2
	
	STR R3, [R0]
	STR R4, [R1]
	BL DRAW_TILE
	
	ADD R3, R3, #32
	STR R3, [R0]
	BL DRAW_TILE
	
	B SKIP_RESET_3
DRAW_2X1
	CMP R5, #12
	BGT DRAW_2X2

	STR R3, [R0]
	STR R4, [R1]
	BL DRAW_TILE
	
	ADD R4, R4, #32
	STR R4, [R1]
	BL DRAW_TILE
	
	B SKIP_RESET_3
DRAW_2X2
	STR R3, [R0]
	STR R4, [R1]
	BL DRAW_TILE
	
	ADD R3, R3, #32
	STR R3, [R0]
	BL DRAW_TILE
	
	ADD R4, R4, #32
	STR R4, [R1]
	BL DRAW_TILE
	
	SUB R3, R3, #32
	STR R3, [R0]
	BL DRAW_TILE
	
SKIP_RESET_3

	POP {R0-R8, PC}
	ENDFUNC
;#####################################################################################################################################################################
DRAW_GRASS	FUNCTION
	;THIS FUNCTION TAKES STARTING X AND STARTING Y THEN DRAWS AN IMAGE
	;ARGUMENTS: R0 = X, R1 = Y
	PUSH{R0-R7, LR}
	
	MOV R3, R1
;	ADD R1, R0, #38
;	ADD R4, R3, #46 ;I KNOW THE HEIGHT IS MORE THAN THE IMAGE, BUT THE EXTRA HEIGHT IS JUST A SAFE MEASURE TO AVOID OVERLAPPING, THE WIDTH SHOULD STRICTLY BE THE SAME AS YOUR PICTURE.

	ADD R1, R0, #31
	ADD R4, R3, #32 ;I KNOW THE HEIGHT IS MORE THAN THE IMAGE, BUT THE EXTRA HEIGHT IS JUST A SAFE MEASURE TO AVOID OVERLAPPING, THE WIDTH SHOULD STRICTLY BE THE SAME AS YOUR PICTURE.

	BL ADDRESS_SET

	MOV R7, #1024 ;-AREA OF THE PHOTO, 39 X 47
	LDR R5, =GRASS

	;MEMORY WRITE
	MOV R2, #0x2C
	BL LCD_COMMAND_WRITE
IMAGE_LOOP6
	LDR R6, [R5], #2	;POST INCREMENT
	MOV R2, R6
	BL LCD_16_DATA_WRITE
	SUB R7, R7, #1
	CMP R7, #0
	BGT IMAGE_LOOP6
	B SKIP_THIS_LINE5
	LTORG
SKIP_THIS_LINE5
 
	POP {R0-R7, PC}

	ENDFUNC
;##################################################################################################################################################################
DRAW_ROAD	FUNCTION
	;THIS FUNCTION TAKES STARTING X AND STARTING Y THEN DRAWS AN IMAGE
	;ARGUMENTS: R0 = X, R1 = Y
	PUSH{R0-R7, LR}
	
	MOV R3, R1
;	ADD R1, R0, #38
;	ADD R4, R3, #46 ;I KNOW THE HEIGHT IS MORE THAN THE IMAGE, BUT THE EXTRA HEIGHT IS JUST A SAFE MEASURE TO AVOID OVERLAPPING, THE WIDTH SHOULD STRICTLY BE THE SAME AS YOUR PICTURE.

	ADD R1, R0, #31
	ADD R4, R3, #32 ;I KNOW THE HEIGHT IS MORE THAN THE IMAGE, BUT THE EXTRA HEIGHT IS JUST A SAFE MEASURE TO AVOID OVERLAPPING, THE WIDTH SHOULD STRICTLY BE THE SAME AS YOUR PICTURE.

	BL ADDRESS_SET

	MOV R7, #1024 ;-AREA OF THE PHOTO, 39 X 47
	LDR R5, =ROAD

	;MEMORY WRITE
	MOV R2, #0x2C
	BL LCD_COMMAND_WRITE
IMAGE_LOOP7
	LDR R6, [R5], #2	;POST INCREMENT
	MOV R2, R6
	BL LCD_16_DATA_WRITE
	SUB R7, R7, #1
	CMP R7, #0
	BGT IMAGE_LOOP7
	 
	POP {R0-R7, PC}

	ENDFUNC
;##################################################################################################################################################################
DRAW_TILE	FUNCTION
	;THIS FUNCTION TAKES STARTING X AND STARTING Y THEN DRAWS AN IMAGE
	;ARGUMENTS: R0 = X, R1 = Y
	PUSH{R0-R9, LR}
	
	LDR R8, =TILE_X
	LDRH R0, [R8]
	LDR R9, =TILE_Y
	LDRH R1, [R9]
	
	
	MOV R3, R1
;	ADD R1, R0, #38
;	ADD R4, R3, #46 ;I KNOW THE HEIGHT IS MORE THAN THE IMAGE, BUT THE EXTRA HEIGHT IS JUST A SAFE MEASURE TO AVOID OVERLAPPING, THE WIDTH SHOULD STRICTLY BE THE SAME AS YOUR PICTURE.

	ADD R1, R0, #31
	ADD R4, R3, #32 ;I KNOW THE HEIGHT IS MORE THAN THE IMAGE, BUT THE EXTRA HEIGHT IS JUST A SAFE MEASURE TO AVOID OVERLAPPING, THE WIDTH SHOULD STRICTLY BE THE SAME AS YOUR PICTURE.

	BL ADDRESS_SET

	MOV R7, #1024 ;-AREA OF THE PHOTO, 39 X 47
	LDR R5, =ROAD

	;MEMORY WRITE
	MOV R2, #0x2C
	BL LCD_COMMAND_WRITE
IMAGE_TILE
	LDR R6, [R5], #2	;POST INCREMENT
	MOV R2, R6
	BL LCD_16_DATA_WRITE
	SUB R7, R7, #1
	CMP R7, #0
	BGT IMAGE_TILE
	 
	POP {R0-R9, PC}

	ENDFUNC
;#####################################################################################################################################################################
LCD_WRITE FUNCTION
	;this function takes what is inside r2 and writes it to the tft
	;this function writes 8 bits only
	;later we will choose whether those 8 bits are considered a command, or just pure data
	;your job is to just write 8-bits (regardless if data or command) to PE0-7 and set WR appropriately
	;arguments: R2 = data to be written to the D0-7 bus

	;TODO: PUSH THE NEEDED REGISTERS TO SAVE THEIR CONTENTS. HINT: Push any register you will modify inside the function, and LR 
	
	PUSH {R0-R5, LR}


	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; SETTING WR to 0 ;;;;;;;;;;;;;;;;;;;;;
	;TODO: RESET WR TO 0
	LDR R1, =GPIOA_ODR
	LDR R3, [R1]
	MOV R4, #0xFFFFF7FF
	AND R3, R3, R4
	STR R3, [R1]
	
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;



	;;;;;;;;;;;;; HERE YOU PUT YOUR DATA which is in R2 TO PE0-7 ;;;;;;;;;;;;;;;;;
	;TODO: SET PE0-7 WITH THE LOWER 8-bits of R2
	;only write the lower byte to PE0-7
	MOV R5, R2
	AND R5, R5, #0xFF
	AND R3, R3, #0xFFFFFF00
	ORR R3, R3, R5
	STR R3, [R1]
	
	
	

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;



	;;;;;;;;;;;;;;;;;;;;;;;;;; SETTING WR to 1 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	;TODO: SET WR TO 1 AGAIN (ie make a rising edge)
	MOV R4, #0x00000800
	ORR R3, R3, R4
	STR R3, [R1]
	
	
	
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;



	;TODO: POP THE REGISTERS YOU JUST PUSHED, and PC
	POP {R0-R5, PC}
	ENDFUNC
;#####################################################################################################################################################################


;#####################################################################################################################################################################
LCD_16_WRITE FUNCTION
	;this function takes what is inside r2 and writes it to the tft
	;this function writes 8 bits only
	;later we will choose whether those 8 bits are considered a command, or just pure data
	;your job is to just write 8-bits (regardless if data or command) to PE0-7 and set WR appropriately
	;arguments: R2 = data to be written to the D0-7 bus

	;TODO: PUSH THE NEEDED REGISTERS TO SAVE THEIR CONTENTS. HINT: Push any register you will modify inside the function, and LR 
	
	PUSH {R0-R8, LR}

	
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; SETTING WR to 0 ;;;;;;;;;;;;;;;;;;;;;
	;TODO: RESET WR TO 0
	LDR R1, =GPIOA_ODR
	LDR R3, [R1]
	MOV R4, #0xFFFFF7FF
	AND R3, R3, R4
	STR R3, [R1]
	
	
	
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;



	;;;;;;;;;;;;; HERE YOU PUT YOUR DATA which is in R2 TO PE0-7 ;;;;;;;;;;;;;;;;;
	;TODO: SET PE0-7 WITH THE LOWER 8-bits of R2
	;only write the lower byte to PE0-7
	MOV R5, R2
	AND R5, R5, #0xFF
	AND R3, R3, #0xFFFFFF00
	ORR R3, R3, R5
	STR R3, [R1]
	
	LDR R7, =GPIOB_ODR
	LDR R8, [R7]
	MOV R5, R2
	LSR R5, #8
	AND R5, R5, #0xFF
	AND R8, R8, #0xFFFFFF00
	ORR R8, R8, R5
	STR R8, [R7]
	
	
	
	
	

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;



	;;;;;;;;;;;;;;;;;;;;;;;;;; SETTING WR to 1 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	;TODO: SET WR TO 1 AGAIN (ie make a rising edge)
	MOV R4, #0x00000800
	ORR R3, R3, R4
	STR R3, [R1]
	
	
	
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;



	;TODO: POP THE REGISTERS YOU JUST PUSHED, and PC
	POP {R0-R8, PC}
	ENDFUNC
;#####################################################################################################################################################################










;#####################################################################################################################################################################
LCD_COMMAND_WRITE FUNCTION
	;this function writes a command to the TFT, the command is read from R2
	;it writes LOW to RS first to specify that we are writing a command not data.
	;then it normally calls the function LCD_WRITE we just defined above
	;arguments: R2 = data to be written on D0-7 bus

	;TODO: PUSH ANY NEEDED REGISTERS
	
	PUSH {R0-R4, LR}

	;;;;;;;;;;;;;;;;;;;;;;;;;; SETTING RD to 1 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	;TODO: SET RD HIGH (we won't need reading anyways, but we must keep read pin to high, which means we will not read anything)
	LDR R1, =GPIOA_ODR
	LDR R3, [R1]
	MOV R4, #0x00000400
	ORR R3, R3, R4
	STR R3, [R1]
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;



	;;;;;;;;;;;;;;;;;;;;;;;;; SETTING RS to 0 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	;TODO: SET RS TO 0 (to specify that we are writing commands not data on the D0-7 bus)
	MOV R4, #0xFFFFEFFF
	AND R3, R3, R4
	STR R3, [R1]
	
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	;TODO: CALL FUNCTION LCD_WRITE
	BL LCD_WRITE


	;TODO: POP ALL REGISTERS YOU PUSHED
	POP {R0-R4, PC}
	ENDFUNC
;#####################################################################################################################################################################






;#####################################################################################################################################################################
LCD_DATA_WRITE FUNCTION
	;this function writes Data to the TFT, the data is read from R2
	;it writes HIGH to RS first to specify that we are writing actual data not a command.
	;arguments: R2 = data

	;TODO: PUSH ANY NEEDED REGISTERS
	PUSH {R0-R4, LR}


	;;;;;;;;;;;;;;;;;;;;;;;;;; SETTING RD to 1 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	;TODO: SET RD HIGH (we won't need reading anyways, but we must keep read pin to high, which means we will not read anything)
	LDR R1, =GPIOA_ODR
	LDR R3, [R1]
	MOV R4, #0x00000400
	ORR R3, R3, R4
	STR R3, [R1]
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	



	;;;;;;;;;;;;;;;;;;;; SETTING RS to 1 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	;TODO: SET RS TO 1 (to specify that we are sending actual data not a command on the D0-7 bus)
	MOV R4, #0x00001000
	ORR R3, R3, R4
	STR R3, [R1]
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;



	;TODO: CALL FUNCTION LCD_WRITE
	BL LCD_WRITE

	;TODO: POP ANY REGISTER YOU PUSHED
	POP {R0-R4, PC}
	ENDFUNC
;#####################################################################################################################################################################
LCD_16_DATA_WRITE FUNCTION
	;this function writes Data to the TFT, the data is read from R2
	;it writes HIGH to RS first to specify that we are writing actual data not a command.
	;arguments: R2 = data

	;TODO: PUSH ANY NEEDED REGISTERS
	PUSH {R0-R4, LR}


	;;;;;;;;;;;;;;;;;;;;;;;;;; SETTING RD to 1 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	;TODO: SET RD HIGH (we won't need reading anyways, but we must keep read pin to high, which means we will not read anything)
	LDR R1, =GPIOA_ODR
	LDR R3, [R1]
	MOV R4, #0x00000400
	ORR R3, R3, R4
	STR R3, [R1]
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	



	;;;;;;;;;;;;;;;;;;;; SETTING RS to 1 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	;TODO: SET RS TO 1 (to specify that we are sending actual data not a command on the D0-7 bus)
	MOV R4, #0x00001000
	ORR R3, R3, R4
	STR R3, [R1]
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;



	;TODO: CALL FUNCTION LCD_WRITE
	BL LCD_16_WRITE

	;TODO: POP ANY REGISTER YOU PUSHED
	POP {R0-R4, PC}
	ENDFUNC
;#####################################################################################################################################################################


; REVISE WITH YOUR TA THE LAST 3 FUNCTIONS (LCD_WRITE, LCD_COMMAND_WRITE AND LCD_DATA_WRITE BEFORE PROCEEDING)




;#####################################################################################################################################################################
LCD_INIT FUNCTION
	;This function executes the minimum needed LCD initialization measures
	;Only the necessary Commands are covered
	;Eventho there are so many more in the DataSheet

	;TODO: PUSH ANY NEEDED REGISTERS
	PUSH {R0-R4, LR}

	;;;;;;;;;;;;;;;;; HARDWARE RESET (putting RST to high then low then high again) ;;;;;;;;;;;;;;;;;;;;;;;;;;;
	;TODO: SET RESET PIN TO HIGH
	LDR R1, =GPIOA_ODR
	LDR R3, [R1]
	MOV R4, #0x00000100
	ORR R3, R3, R4
	STR R3, [R1]

	;TODO: DELAY FOR SOME TIME (USE ANY FUNCTION AT THE BOTTOM OF THIS FILE)
	BL DELAY_10_MILLI_SEC

	;TODO: RESET RESET PIN TO LOW
	MOV R4, #0xFFFFFEFF
	AND R3, R3, R4
	STR R3, [R1]

	;TODO: DELAY FOR SOME TIME (USE ANY FUNCTION AT THE BOTTOM OF THIS FILE)
	BL DELAY_10_MILLI_SEC

	;TODO: SET RESET PIN TO HIGH AGAIN
	MOV R4, #0x00000100
	ORR R3, R3, R4
	STR R3, [R1]

	;TODO: DELAY FOR SOME TIME (USE ANY FUNCTION AT THE BOTTOM OF THIS FILE)
	BL DELAY_10_MILLI_SEC
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;






	;;;;;;;;;;;;;;;;; PREPARATION FOR WRITE CYCLE SEQUENCE (setting CS to high, then configuring WR and RD, then resetting CS to low) ;;;;;;;;;;;;;;;;;;
	;TODO: SET CS PIN HIGH
	MOV R4, #0x00008000
	ORR R3, R3, R4
	STR R3, [R1]

	;TODO: SET WR PIN HIGH
	MOV R4, #0x00000800
	ORR R3, R3, R4
	STR R3, [R1]

	;TODO: SET RD PIN HIGH
	MOV R4, #0x00000400
	ORR R3, R3, R4
	STR R3, [R1]

	;TODO: SET CS PIN LOW
	MOV R4, #0xFFFF7FFF
	AND R3, R3, R4
	STR R3, [R1]
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	B SKIP_THIS_LINE
	LTORG
SKIP_THIS_LINE




	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; SOFTWARE INITIALIZATION SEQUENCE ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	;ISSUE THE "SET CONTRAST" COMMAND, ITS HEX CODE IS 0xC5
	MOV R2, #0xC5
	BL LCD_COMMAND_WRITE

	;THIS COMMAND REQUIRES 2 PARAMETERS TO BE SENT AS DATA, THE VCOM H, AND THE VCOM L
	;WE WANT TO SET VCOM H TO A SPECIFIC VOLTAGE WITH CORRESPONDS TO A BINARY CODE OF 1111111 OR 0x7F HEXA
	;SEND THE FIRST PARAMETER (THE VCOM H) NEEDED BY THE COMMAND, WITH HEX 0x7F, PARAMETERS ARE SENT AS DATA BUT COMMANDS ARE SENT AS COMMANDS
	MOV R2, #0x7F
	BL LCD_DATA_WRITE

	;WE WANT TO SET VCOM L TO A SPECIFIC VOLTAGE WITH CORRESPONDS TO A BINARY CODE OF 00000000 OR 0x00 HEXA
	;SEND THE SECOND PARAMETER (THE VCOM L) NEEDED BY THE CONTRAST COMMAND, WITH HEX 0x00, PARAMETERS ARE SENT AS DATA BUT COMMANDS ARE SENT AS COMMANDS
	MOV R2, #0x00
	BL LCD_DATA_WRITE


	;MEMORY ACCESS CONTROL AKA MADCLT | DATASHEET PAGE 127
	;WE WANT TO SET MX (to draw from left to right) AND SET MV (to configure the TFT to be in horizontal landscape mode, not a vertical screen)
	;TODO: ISSUE THE COMMAND MEMORY ACCESS CONTROL, HEXCODE 0x36
	MOV R2, #0x36
	BL LCD_COMMAND_WRITE

	;TODO: SEND ONE NEEDED PARAMETER ONLY WITH MX AND MV SET TO 1. HOW WILL WE SEND PARAMETERS? AS DATA OR AS COMMAND?
	MOV R2, #0x28
	BL LCD_DATA_WRITE



	;COLMOD: PIXEL FORMAT SET | DATASHEET PAGE 134
	;THIS COMMAND LETS US CHOOSE WHETHER WE WANT TO USE 16-BIT COLORS OR 18-BIT COLORS.
	;WE WILL ALWAYS USE 16-BIT COLORS
	;TODO: ISSUE THE COMMAND COLMOD
	MOV R2, #0x3A
	BL LCD_COMMAND_WRITE
	
	
	

	;TODO: SEND THE NEEDED PARAMETER WHICH CORRESPONDS TO 16-BIT RGB AND 16-BIT MCU INTERFACE FORMAT
	MOV R2, #0x55
	BL LCD_DATA_WRITE
	
	

	;SLEEP OUT | DATASHEET PAGE 101
	;TODO: ISSUE THE SLEEP OUT COMMAND TO EXIT SLEEP MODE (THIS COMMAND TAKES NO PARAMETERS, JUST SEND THE COMMAND)
	MOV R2, #0x11
	BL LCD_COMMAND_WRITE

	;NECESSARY TO WAIT 5ms BEFORE SENDING NEXT COMMAND
	;I WILL WAIT FOR 10MSEC TO BE SURE
	;TODO: DELAY FOR AT LEAST 10ms
	BL DELAY_10_MILLI_SEC


	;DISPLAY ON | DATASHEET PAGE 109
	;TODO: ISSUE THE COMMAND, IT TAKES NO PARAMETERS
	MOV R2, #0x29
	BL LCD_COMMAND_WRITE


	;COLOR INVERSION OFF | DATASHEET PAGE 105
	;NOTE: SOME TFTs HAS COLOR INVERTED BY DEFAULT, SO YOU WOULD HAVE TO INVERT THE COLOR MANUALLY SO COLORS APPEAR NATURAL
	;MEANING THAT IF THE COLORS ARE INVERTED WHILE YOU ALREADY TURNED OFF INVERSION, YOU HAVE TO TURN ON INVERSION NOT TURN IT OFF.
	;TODO: ISSUE THE COMMAND, IT TAKES NO PARAMETERS
	MOV R2, #0x21
	BL LCD_COMMAND_WRITE



	;MEMORY WRITE | DATASHEET PAGE 245
	;WE NEED TO PREPARE OUR TFT TO SEND PIXEL DATA, MEMORY WRITE SHOULD ALWAYS BE ISSUED BEFORE ANY PIXEL DATA SENT
	;TODO: ISSUE MEMORY WRITE COMMAND
	MOV R2, #0x2C
	BL LCD_COMMAND_WRITE	
	
	



	;TODO: POP ALL PUSHED REGISTERS
	POP {R0-R4, PC}	
	ENDFUNC
;#####################################################################################################################################################################


;#####################################################################################################################################################################
ADDRESS_SET FUNCTION
	;THIS FUNCTION TAKES X1, X2, Y1, Y2
	;IT ISSUES COLUMN ADDRESS SET TO SPECIFY THE START AND END COLUMNS (X1 AND X2)
	;IT ISSUES PAGE ADDRESS SET TO SPECIFY THE START AND END PAGE (Y1 AND Y2)
	;THIS FUNCTION JUST MARKS THE PLAYGROUND WHERE WE WILL ACTUALLY DRAW OUR PIXELS, MAYBE TARGETTING EACH PIXEL AS IT IS.
	;R0 = X1
	;R1 = X2
	;R3 = Y1
	;R4 = Y2

	;PUSHING ANY NEEDED REGISTERS
	PUSH {R0-R4, LR}
	

	;COLUMN ADDRESS SET | DATASHEET PAGE 110
	MOV R2, #0x2A
	BL LCD_COMMAND_WRITE

	;TODO: SEND THE FIRST PARAMETER (HIGHER 8-BITS OF THE STARTING COLUMN, AKA HIGHER 8-BITS OF X1)
	MOV R2, R0
	LSR R2, #8
	BL LCD_DATA_WRITE

	;TODO: SEND THE SECOND PARAMETER (LOWER 8-BITS OF THE STARTING COLUMN, AKA LOWER 8-BITS OF X1)
	MOV R2, R0
	BL LCD_DATA_WRITE


	;TODO: SEND THE THIRD PARAMETER (HIGHER 8-BITS OF THE ENDING COLUMN, AKA HIGHER 8-BITS OF X2)
	MOV R2, R1
	LSR R2, #8
	BL LCD_DATA_WRITE

	;TODO: SEND THE FOURTH PARAMETER (LOWER 8-BITS OF THE ENDING COLUMN, AKA LOWER 8-BITS OF X2)
	MOV R2, R1
	BL LCD_DATA_WRITE



	;PAGE ADDRESS SET | DATASHEET PAGE 110
	MOV R2, #0x2B
	BL LCD_COMMAND_WRITE

	;TODO: SEND THE FIRST PARAMETER (HIGHER 8-BITS OF THE STARTING PAGE, AKA HIGHER 8-BITS OF Y1)
	MOV R2, R3
	LSR R2, #8
	BL LCD_DATA_WRITE

	;TODO: SEND THE SECOND PARAMETER (LOWER 8-BITS OF THE STARTING PAGE, AKA LOWER 8-BITS OF Y1)
	MOV R2, R3
	BL LCD_DATA_WRITE


	;TODO: SEND THE THIRD PARAMETER (HIGHER 8-BITS OF THE ENDING PAGE, AKA HIGHER 8-BITS OF Y2)
	MOV R2, R4
	LSR R2, #8
	BL LCD_DATA_WRITE

	;TODO: SEND THE FOURTH PARAMETER (LOWER 8-BITS OF THE ENDING PAGE, AKA LOWER 8-BITS OF Y2)
	MOV R2, R4
	BL LCD_DATA_WRITE

	;MEMORY WRITE
	MOV R2, #0x2C
	BL LCD_COMMAND_WRITE


	;POPPING ALL REGISTERS I PUSHED
	POP {R0-R4, PC}
	ENDFUNC
;#####################################################################################################################################################################



;#####################################################################################################################################################################
DRAWPIXEL FUNCTION
	PUSH {R0-R4, r10, LR}
	;THIS FUNCTION TAKES X AND Y AND A COLOR AND DRAWS THIS EXACT PIXEL
	;NOTE YOU HAVE TO CALL ADDRESS SET ON A SPECIFIC PIXEL WITH LENGTH 1 AND WIDTH 1 FROM THE STARTING COORDINATES OF THE PIXEL, THOSE STARTING COORDINATES ARE GIVEN AS PARAMETERS
	;THEN YOU SIMPLY ISSUE MEMORY WRITE COMMAND AND SEND THE COLOR
	;R0 = X
	;R1 = Y
	;R10 = C
	;CHIP SELECT ACTIVE, WRITE LOW TO CS
	LDR r3, =GPIOA_ODR
	LDR r4, [r3]
	AND r4, r4, #0xFFFF7FFF
	STR r4, [r3]

	;TODO: SETTING PARAMETERS FOR FUNC 'ADDRESS_SET' CALL, THEN CALL FUNCTION ADDRESS SET
	;NOTE YOU MIGHT WANT TO PERFORM PARAMETER REORDERING, AS ADDRESS SET FUNCTION TAKES X1, X2, Y1, Y2 IN R0, R1, R3, R4 BUT THIS FUNCTION TAKES X,Y IN R0 AND R1
	MOV R3, R1
	MOV R1, R0
	ADD R1, #1
	MOV R4, R3
	ADD R4, #1
	BL ADDRESS_SET


	
	;MEMORY WRITE
	MOV R2, #0x2C
	BL LCD_COMMAND_WRITE


	;SEND THE COLOR DATA | DATASHEET PAGE 114
	;HINT: WE SEND THE HIGHER 8-BITS OF THE COLOR FIRST, THEN THE LOWER 8-BITS
	;HINT: WE SEND THE COLOR OF ONLY 1 PIXEL BY 2 DATA WRITES, THE FIRST TO SEND THE HIGHER 8-BITS OF THE COLOR, THE SECOND TO SEND THE LOWER 8-BITS OF THE COLOR
	;REMINDER: WE USE 16-BIT PER PIXEL COLOR
	;TODO: SEND THE SINGLE COLOR, PASSED IN R10


	MOV R2, R10
	BL LCD_16_DATA_WRITE
	


	
	POP {R0-R4, r10, PC}
	
	ENDFUNC
;#####################################################################################################################################################################


;	REVISE THE PREVIOUS TWO FUNCTIONS (ADDRESS_SET AND DRAW_PIXEL) WITH YOUR TA BEFORE PROCEEDING








;##########################################################################################################################################
DRAW_RECTANGLE_FILLED_A FUNCTION
	;TODO: IMPLEMENT THIS FUNCTION ENTIRELY, AND SPECIFY THE ARGUMENTS IN COMMENTS, WE DRAW A RECTANGLE BY SPECIFYING ITS TOP-LEFT AND LOWER-RIGHT POINTS, THEN FILL IT WITH THE SAME COLOR
	;X1 = [] r0
	;Y1 = [] r1
	;X2 = [] r3
	;Y2 = [] r4
	;COLOR = [] r10
	PUSH {R0-R5, r10, LR}
	;CALC AREA
	SUB R5, R3, R0
	SUB R6, R4, R1
	ADD R6, R6, #1
	MUL R6, R5, R6
	
	;AREA IS IN R6
	
	;;ADDRESS SET
	;X1 X2 Y1 Y2
	;R0 R1 R3 R4
	PUSH {R1}
	PUSH {R3}
	POP {R1}
	POP {R3}
	BL ADDRESS_SET
	
	
	;MEMORY WRITE
	MOV R2, #0x2C
	BL LCD_COMMAND_WRITE
	
DRAW_RECT_LOOP
	;SEND HUGHER 8 BITS
	;SEND LOWER 8 BITS
	;MOV R2, R10
	;LSR R2, #8
	;BL LCD_DATA_WRITE
	
	MOV R2, R10
	BL LCD_16_DATA_WRITE
	
	;DEC AREA
	SUB R6, R6, #1
	CMP R6, #0
	BGT DRAW_RECT_LOOP
	
	POP {R0-R5, r10, PC}
	
	ENDFUNC
;##########################################################################################################################################
SPAWN_BULLET FUNCTION
	;Takes R0 as X To spawn bullet from top
	 PUSH {R0-R3, LR}
	 LDR R1,=ISSHOT
	 LDR R3,[R1]
	 CMP R3,#0
	 BNE CANTSPAWN
	 MOV R3,#1
	 STR R3,[R1]
	 LDR R3,=BULLET_X
	 STR R0,[R3]
	 LDR R3,=BULLET_Y
	 MOV R1,#0
	 STR R1,[R3]
	 BL DRAW_BULLET_RED
CANTSPAWN	 
	 POP {R0-R3, PC}
	ENDFUNC
;##########################################################################################################################################
MOVE_BULLET_DOWN FUNCTION
	PUSH{R0-R4, LR}
	LDR R0, =RESET_W
	MOV R1, #8
	STRH R1, [R0]
	LDR R0, =RESET_H
	MOV R1, #16
	STRH R1, [R0]
	
	LDR R0, =BULLET_X
	LDR R1, [R0]
	LDR R0, =RESET_X
	STR R1, [R0]
	
	LDR R0, =BULLET_Y
	LDR R1, [R0]
	LDR R0, =RESET_Y
	STR R1, [R0]
	
	LDR R3,=BULLET_X
	LDR R4,=BULLET_Y
	LDRH R0,[R3]
	LDRH R1,[R4]
	ADD R1,R1,#4
	CMP R1,#298
	BGT OUTBOUNDS
	BL DRAW_BULLET_RED
	STRH R1,[R4]
OUTBOUNDS
	CMP R1,#298
	BLT STILLSHOT
	LDR R3,=ISSHOT
	MOV R4,#0
	STR R4,[R3]
	LDR R3,=NEXT_BULLET_INDEX
	LDR R4,[R3]
	ADD R4,R4,#1
	STR R4,[R3]
	CMP R4,#7
	BNE NOT7
	MOV R4,#0
	STR R4,[R3]
NOT7	
STILLSHOT	
	BL RESET_CHAR_BG
	
	POP {R0-R4, PC}
	ENDFUNC
;##########################################################################################################################################
DRAW_BULLET_RED	FUNCTION
	;ARGUMENTS: R0 = X, R1 = Y
	PUSH{R0-R4, LR}
	MOV R3, R1

	ADD R1, R0, #7 ;Width line -1
	ADD R4, R3, #16 ;I KNOW THE HEIGHT IS MORE THAN THE IMAGE, BUT THE EXTRA HEIGHT IS JUST A SAFE MEASURE TO AVOID OVERLAPPING, THE WIDTH SHOULD STRICTLY BE THE SAME AS YOUR PICTURE.

	BL ADDRESS_SET

	MOV R4, #128 ;-AREA OF THE PHOTO, 

	;MEMORY WRITE
	MOV R2, #0x2C
	BL LCD_COMMAND_WRITE
IMAGE_LOOP_RED
	MOV R2, #0xe8e4
	BL LCD_16_DATA_WRITE
	SUB R4, R4, #1
	CMP R4, #0
	BGT IMAGE_LOOP_RED
 
	POP {R0-R4, PC}

	ENDFUNC
;##########################################################################################################################################
DRAW_RECTANGLE_FILLED FUNCTION
	;TODO: IMPLEMENT THIS FUNCTION ENTIRELY, AND SPECIFY THE ARGUMENTS IN COMMENTS, WE DRAW A RECTANGLE BY SPECIFYING ITS TOP-LEFT AND LOWER-RIGHT POINTS, THEN FILL IT WITH THE SAME COLOR
	;X1 = [] r0
	;Y1 = [] r1
	;X2 = [] r3
	;Y2 = [] r4
	;COLOR = [] r10
	PUSH {R0-R5, r10, LR}
	
		MOV R5, R1
DRAW2
	MOV R1, R5
DRAW1
	BL DRAWPIXEL
	ADD R1, #1
	CMP R1, R4
	BNE DRAW1
	ADD R0, #1
	CMP R0, R3
	BNE DRAW2
	
	POP {R0-R5, r10, PC}
	ENDFUNC
;##########################################################################################################################################













;#####################################################################################################################################################################
SETUP FUNCTION
	;THIS FUNCTION ENABLES PORT E, MARKS IT AS OUTPUT, CONFIGURES SOME GPIO
	;THEN FINALLY IT CALLS LCD_INIT (HINT, USE THIS SETUP FUNCTION DIRECTLY IN THE MAIN)
	PUSH {R0-R1, LR}
    
	;Make the clock affect port E by enabling the corresponding bit (the third bit) in RCC_AHB1ENR register
	LDR r1, =RCC_AHB1ENR
	LDR r0, [r1, #0]
	ORR r0, r0, #0x3
	STR r0, [r1, #0]
	
	
	;Make the GPIO E mode as output (01 for each pin)
	LDR r0, =GPIOA_BASE
	LDR R1, [R0]
	MOV R1, #0x6955
	LSL R1, #8
	ADD R1, R1, #0x55
	LSL R1, #8
	ADD R1, R1, #0x55
	STR R1, [R0]
	
	LDR r0, =GPIOB_BASE
	LDR R1, [R0]
	MOV R1, #0x5555
	STR R1, [R0]
	
	
	;Make the Output type as Push-Pull not Open-drain, by clearing all the bits in the lower 2 bytes of OTYPE register, the higher 2 bytes are reserved.
	mov r0, #0
	LDR r1, =GPIOA_OTYPER
	STRH r0, [r1]
	
	mov r0, #0
	LDR r1, =GPIOB_OTYPER
	STRH r0, [r1]
	
	;Make the Output speed as super fast by clearing all the bits in the OSPEED register
	;00 means slow
	;01 means medium
	;10 means fast
	;11 means super fast
	;2 bits for each pin and we will choose slow
	;this register just scales the time of flipping from low to high or from high to low.
	mov r0, #0xFFFFFFFF
	LDR r1, =GPIOA_OSPEEDR
	STR r0, [r1]
	
	mov r0, #0xFFFFFFFF
	LDR r1, =GPIOB_OSPEEDR
	STR r0, [r1]
	
	
	;Clear the Pullup-pulldown bits for each port, we don't need the internal resistors
	mov r0, #0
	LDR r1, =GPIOA_BASE
	ADD r1, r1, #0x0c	;go to PUPDR of GPIOE which is at offset 0x0C from base of GPIOE
	STR r0, [r1]
	
	
	mov r0, #0
	LDR r1, =GPIOB_BASE
	ADD r1, r1, #0x0c	;go to PUPDR of GPIOE which is at offset 0x0C from base of GPIOE
	STR r0, [r1]



	LDR r1, =GPIOA_ODR
	LDR r0, [r1]
	ORR r0, #0x00007F00
	STRH r0, [r1]
	
	LDR r1, =GPIOB_ODR
	LDR r0, [r1]
	ORR r0, #0x00007F00
	STRH r0, [r1]
	
	LDR R0, =GPIOB_PUPDR
	MOV R1, #0x5555
	LSL R1, #16
	STR R1, [R0]
	
	mov r0, #0
	LDR r1, =GPIOB_OTYPER
	STRH r0, [r1]
	
	B SKIP_THIS_LINE2
	LTORG
SKIP_THIS_LINE2

	BL LCD_INIT

	POP {R0-R1, PC}
	ENDFUNC
;#####################################################################################################################################################################



;##################################################################################################################################################################
;Delays for 1 Millisecond
DELAY_1_MILLI_SEC FUNCTION
	
	PUSH {R8, LR}
	
	LDR r8, =INTERVAL_1MS
DELAY_LOOP_1MS
	SUBS r8, #1
	CMP r8, #0
	BGE DELAY_LOOP_1MS
	
	POP {R8, PC}
	
	ENDFUNC
;##################################################################################################################################################################

;##################################################################################################################################################################
;Delays for 10 Milliseconds
DELAY_10_MILLI_SEC FUNCTION
	
	PUSH {R8, LR}
	
	LDR r8, =INTERVAL_10MS
DELAY_LOOP_10MS
	SUBS r8, #1
	CMP r8, #0
	BGE DELAY_LOOP_10MS
	POP {R8, PC}
	
	ENDFUNC
;##################################################################################################################################################################	

;##################################################################################################################################################################
;Delays for 100 Milliseconds
DELAY_100_MILLI_SEC FUNCTION
	
	PUSH {R8, LR}
	
	LDR r8, =INTERVAL_100MS
DELAY_LOOP_100MS
	SUBS r8, #1
	CMP r8, #0
	BGE DELAY_LOOP_100MS
	POP {R8, PC}
	
	ENDFUNC
;##################################################################################################################################################################

;##################################################################################################################################################################
;Delays for 1 Second
DELAY_1_SEC FUNCTION
	
	PUSH {R8, LR}
	
	LDR r8, =INTERVAL_1000MS
DELAY_LOOP_SEC
	SUBS r8, #1
	CMP r8, #0
	BGE DELAY_LOOP_SEC
	
	POP {R8, PC}
	
	ENDFUNC
;##################################################################################################################################################################	

;##################################################################################################################################################################
;Delays for 10 Seconds
DELAY_10_SEC FUNCTION
	
	PUSH {R8, LR}
	
	LDR r8, =INTERVAL_10S
DELAY_LOOP_10S
	SUBS r8, #1
	CMP r8, #0
	BGE DELAY_LOOP_10S
	
	POP {R8, PC}
	
	ENDFUNC
;##################################################################################################################################################################


;##################################################################################################################################################################
DRAW_PALESTINE FUNCTION
	
	MOV R0, #0
	MOV R1, #0
	MOV R3, #480
	MOV R4, #110
	MOV R10, #BLACK
	BL DRAW_RECTANGLE_FILLED_A


	MOV R0, #0
	MOV R1, #110
	MOV R3, #480
	MOV R4, #210
	MOV R10, #WHITE
	BL DRAW_RECTANGLE_FILLED_A
	
	MOV R0, #0
	MOV R1, #210
	MOV R3, #480
	MOV R4, #320
	MOV R10, #GREEN2
	BL DRAW_RECTANGLE_FILLED_A
	
	MOV R0, #0
	MOV R1, #0
	MOV R3, #1
	MOV R4, #320
	MOV R10, #RED
TRI
	BL DRAW_RECTANGLE_FILLED
	ADD R0, R0, #1
	ADD R3, R3, #1
	ADD R1, R1, #1
	SUB R4, R4, #1
	CMP R1, R4
	BNE TRI
	
	
	ENDFUNC

;##################################################################################################################################################################
;##################################################################################################################################################################
DRAW_NEON FUNCTION
	PUSH {R0-R12, LR}
	
	MOV R0, #0
	MOV R1, #0
	MOV R3, #480
	MOV R4, #320
	MOV R10, #BLACK
	BL DRAW_RECTANGLE_FILLED_A
	
	MOV R0, #190
	MOV R1, #70
	BL DRAW_NEON_TITLE
	
	MOV R0, #214
	MOV R1, #200
	BL DRAW_NEON_START
	
	
	PUSH {R0-R2}
WAITING_FOR_START_NC
	LDR R0,=GPIOB_IDR
	LDR R1,[R0]
	MOV R2,#0XEF00
	CMP R1,R2
	BEQ STARTING
	B WAITING_FOR_START_NC
STARTING
	POP {R0-R2}
	BL NEON_RACERS
	
	

	
	POP {R0-R12, PC}
	ENDFUNC




MOVE_COMP_CAR_UP	FUNCTION
	PUSH{R0-R12,LR}

	ldr		r1, =COMP_CAR_Y
	ldrh	r0, [r1]
	SUB	r0, r0, #5
	
	mov 	r6, #0xFFFF
	and		r6, r6, r0
	add 	r6,r6,#16
	mov 	r7, #16
	cmp		r7, r6	
	bge		loly4
	
	strh	r0, [r1]
	push {R0-R12}
	
	
	ldr		r5, =COMP_CAR_Y
	ldrh		r5, [r5]
	mov		r0, r5
	
	ADD		r0, r0, #5
	
	ldr		r5, =COMP_CAR_X
	ldrh		r5, [r5]
	mov		r1, r5
	
	;X1 = [] r0
	;Y1 = [] r1
	;X2 = [] r3
	;Y2 = [] r4
	;Exchange r0 and r1 
	
	mov r11, r0
	mov r0,r1
	mov r1, r11
	
	mov		r6, #12
	MOV 	R7, #16
	add		r3, r0, r6
	add		r4, r1, R7
	mov		r10, #BLACK
	bl		DRAW_RECTANGLE_FILLED
	MOV R8, #1
	bl 		DRAW_TRAIL_UP
	
	pop {R0-R12}
	MOV R8, #1
	bl	DRAW_MAIN_CAR_UP
	B LOLY44
loly4
	LDR R0 , =COMP_COLLIDED
	MOV R1, #1
	LDR R1 , [R0]
LOLY44
	
	POP{R0-R12,PC}
	ENDFUNC

;##################################################################################################################################################################

MOVE_MAIN_CAR_UP	FUNCTION
	PUSH{R0-R12,LR}

	ldr		r1, =MAIN_CAR_Y
	ldrh	r0, [r1]
	SUB	r0, r0, #5
	
	mov 	r6, #0xFFFF
	and		r6, r6, r0
	add 	r6,r6,#16
	mov 	r7, #16
	cmp		r7, r6	
	bge		lolx4
	
	strh	r0, [r1]
	push {R0-R12}
	
	
	ldr		r5, =MAIN_CAR_Y
	ldrh		r5, [r5]
	mov		r0, r5
	
	ADD		r0, r0, #5
	
	ldr		r5, =MAIN_CAR_X
	ldrh		r5, [r5]
	mov		r1, r5
	
	;X1 = [] r0
	;Y1 = [] r1
	;X2 = [] r3
	;Y2 = [] r4
	;Exchange r0 and r1 
	
	mov r11, r0
	mov r0,r1
	mov r1, r11
	
	mov		r6, #12
	MOV 	R7, #16
	add		r3, r0, r6
	add		r4, r1, R7
	mov		r10, #BLACK
	bl		DRAW_RECTANGLE_FILLED
	bl 		DRAW_TRAIL_UP
	
	pop {R0-R12}
	bl	DRAW_MAIN_CAR_UP
	B LOLX41
lolx4
	LDR R0 , =MAIN_COLLIDED
	MOV R1, #1
	LDR R1 , [R0]
LOLX41
	
	
	POP{R0-R12,PC}
	ENDFUNC

;##################################################################################################################################################################
TRAIL_COLLISION FUNCTION
	PUSH{R0-R12,LR}
	;R0 = X1
	;R1 = Y1
	;R2 = ORIENTAION
	;R3 = X2
	;R4 = Y2
	
	LDR	R5, =MAIN_CAR_X
	LDRH	R0, [R5]
	
	LDR R5, =MAIN_CAR_Y
	LDRH	R1, [R5]
	
	LDR R5,=ORIENTATION_MAIN
	LDRH	R2, [R5]
	
	
	
	CMP R2 , #1
	BEQ LOOP_HORIZONTAL_ARRAY_FOR_COLLISION
	CMP R2, #3
	BEQ LOOP_HORIZONTAL_ARRAY_FOR_COLLISION
	CMP R2 , #2
	BEQ LOOP_VERTICAL_ARRAY_FOR_COLLISION
	CMP R2 , #4
	BEQ LOOP_VERTICAL_ARRAY_FOR_COLLISION
	
	
	;r0 -> x
	;r1 -> y
	;R2 -> ORIENTATION
	
LOOP_HORIZONTAL_ARRAY_FOR_COLLISION

	;SIZE 1 -> (12,16)
	;SIZE 2 -> (5,4)
	LDR R7 , =HORIZONTAL_TRAIL_COUNT
	LDRH R7, [R7]
	CMP R7, #0
	BEQ FINISH_CHECK
	
	
	LDR R8, =TRAILS_HORIZONTAL_X
	LDR R9, =TRAILS_HORIZONTAL_Y
LOOP_ARRAY_HORIZONTAL_COLLISION 
	LDRH	R10, [R8], #2    ;R10 -> X OF TRAIL
	LDRH 	R11, [R9], #2	 ;R11 -> Y OF TRAIL 
	; CHECK FOR COLLISON
	;POS1.X ->R0
	; POS1.Y -> R1
	; POS2.X -> R10
	; POS2.Y -> R11
	; SIZE1.X -> 12
	; SIZE1.Y -> 16
	;SIZE 2.X -> 5
	;SIZE2.Y -> 4
	;    if ((Pos1.x < Pos2.x + Size2.x) &&
    ;   (Pos1.y < Pos2.y + Size2.y) &&
    ;  	(Pos2.x < Pos1.x + Size1.x) &&
    ;  	(Pos2.y < Pos1.y + Size1.y))
	ADD R5 , R10 , #5
	CMP R0 , R5
	BGT NO_COLLISION_HORIZONTAL
	ADD R5 , R11, #4
	CMP R1 , R5
	BGT NO_COLLISION_HORIZONTAL
	ADD R5 , R0 , #12
	CMP R10 , R5
	BGT NO_COLLISION_HORIZONTAL
	ADD R5 , R1 , #16
	CMP R11 , R5
	BGT NO_COLLISION_HORIZONTAL
	
	LDR R0 , =MAIN_COLLIDED
	MOV R1, #1
	LDR R1 , [R0]
	B COLLISION_HORIZONTAL
	
	 
	
	;-------------------
NO_COLLISION_HORIZONTAL
	;POS1.X ->R0
	; POS1.Y -> R1
	; POS2.X -> R10
	; POS2.Y -> R11
	; SIZE1.X -> 12
	; SIZE1.Y -> 16
	;SIZE 2.X -> 5
	;SIZE2.Y -> 4
	;    if ((Pos1.x < Pos2.x + Size2.x) &&
    ;   (Pos1.y < Pos2.y + Size2.y) &&
    ;  	(Pos2.x < Pos1.x + Size1.x) &&
    ;  	(Pos2.y < Pos1.y + Size1.y))
	CMP R7,#0
	BEQ FINISH_CHECK
	SUB R7, R7 , #1
	CMP R7 , #2
	BEQ FINISH_CHECK
	B LOOP_ARRAY_HORIZONTAL_COLLISION
	



LOOP_VERTICAL_ARRAY_FOR_COLLISION
	LDR R7 , =VERTICAL_TRAIL_COUNT
	LDRH R7, [R7]
	CMP R7, #0
	BEQ FINISH_CHECK
	
	LDR R8, =TRAILS_VERTICAL_X
	LDR R9, =TRAILS_VERTICAL_Y

LOOP_ARRAY_VERTICAL_COLLISION 
	LDRH	R10, [R8], #2    ;R10 -> X OF TRAIL
	LDRH 	R11, [R9], #2	 ;R11 -> Y OF TRAIL 
	; CHECK FOR COLLISON
	;POS1.X ->R0
	; POS1.Y -> R1
	; POS2.X -> R10
	; POS2.Y -> R11
	; SIZE1.X -> 16
	; SIZE1.Y -> 12
	;SIZE 2.X -> 4
	;SIZE2.Y -> 5
	;    if ((Pos1.x < Pos2.x + Size2.x) &&
    ;   (Pos1.y < Pos2.y + Size2.y) &&
    ;  	(Pos2.x < Pos1.x + Size1.x) &&
    ;  	(Pos2.y < Pos1.y + Size1.y))
	ADD R5 , R10 , #4
	CMP R0 , R5
	BGT NO_COLLISION_VERTICAL
	ADD R5 , R11, #5
	CMP R1 , R5
	BGT NO_COLLISION_VERTICAL
	ADD R5 , R0 , #16
	CMP R10 , R5
	BGT NO_COLLISION_VERTICAL
	ADD R5 , R1 , #12
	CMP R11 , R5
	BGT NO_COLLISION_VERTICAL
	
	
	LDR R0 , =MAIN_COLLIDED
	MOV R1, #1
	LDR R1 , [R0]
	B COLLISION_VERTICAL
	
	;-------------------
NO_COLLISION_VERTICAL
	
	CMP R7, #0
	BEQ FINISH_CHECK
	SUB R7, R7 , #1
	CMP R7 , #2
	BEQ FINISH_CHECK
	B LOOP_ARRAY_VERTICAL_COLLISION
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
FINISH_CHECK
	
	
;----------------------------------------
;----------------------------------------
;----------------------------------------
;----------------------------------------
;R0 = X1
	;R1 = Y1
	;R2 = ORIENTAION
	;R3 = X2
	;R4 = Y2
	
	LDR	R5, =COMP_CAR_X
	LDRH	R0, [R5]
	
	LDR R5, =COMP_CAR_Y
	LDRH	R1, [R5]
	
	LDR R5,=ORIENTATION_COMP
	LDRH	R2, [R5]
	
	
	
	CMP R2 , #1
	BEQ LOOP_HORIZONTAL_ARRAY_FOR_COLLISION2
	CMP R2, #3
	BEQ LOOP_HORIZONTAL_ARRAY_FOR_COLLISION2
	CMP R2 , #2
	BEQ LOOP_VERTICAL_ARRAY_FOR_COLLISION2
	CMP R2 , #4
	BEQ LOOP_VERTICAL_ARRAY_FOR_COLLISION2
	
	
	;r0 -> x
	;r1 -> y
	;R2 -> ORIENTATION
	
LOOP_HORIZONTAL_ARRAY_FOR_COLLISION2

	;SIZE 1 -> (12,16)
	;SIZE 2 -> (5,4)
	LDR R7 , =HORIZONTAL_TRAIL_COUNT
	LDRH R7, [R7]
	CMP R7, #0
	BEQ FINISH_INT
	
	
	LDR R8, =TRAILS_HORIZONTAL_X
	LDR R9, =TRAILS_HORIZONTAL_Y
LOOP_ARRAY_HORIZONTAL_COLLISION2 
	LDRH	R10, [R8], #2    ;R10 -> X OF TRAIL
	LDRH 	R11, [R9], #2	 ;R11 -> Y OF TRAIL 
	; CHECK FOR COLLISON
	;POS1.X ->R0
	; POS1.Y -> R1
	; POS2.X -> R10
	; POS2.Y -> R11
	; SIZE1.X -> 12
	; SIZE1.Y -> 16
	;SIZE 2.X -> 5
	;SIZE2.Y -> 4
	;    if ((Pos1.x < Pos2.x + Size2.x) &&
    ;   (Pos1.y < Pos2.y + Size2.y) &&
    ;  	(Pos2.x < Pos1.x + Size1.x) &&
    ;  	(Pos2.y < Pos1.y + Size1.y))
	ADD R5 , R10 , #5
	CMP R0 , R5
	BGT NO_COLLISION_HORIZONTAL2
	ADD R5 , R11, #4
	CMP R1 , R5
	BGT NO_COLLISION_HORIZONTAL2
	ADD R5 , R0 , #12
	CMP R10 , R5
	BGT NO_COLLISION_HORIZONTAL2
	ADD R5 , R1 , #16
	CMP R11 , R5
	BGT NO_COLLISION_HORIZONTAL2
	
	LDR R0 , =COMP_COLLIDED
	MOV R1, #1
	LDR R1 , [R0]
	B COLLISION_HORIZONTAL

	
	 
	
	;-------------------
NO_COLLISION_HORIZONTAL2
	;POS1.X ->R0
	; POS1.Y -> R1
	; POS2.X -> R10
	; POS2.Y -> R11
	; SIZE1.X -> 12
	; SIZE1.Y -> 16
	;SIZE 2.X -> 5
	;SIZE2.Y -> 4
	;    if ((Pos1.x < Pos2.x + Size2.x) &&
    ;   (Pos1.y < Pos2.y + Size2.y) &&
    ;  	(Pos2.x < Pos1.x + Size1.x) &&
    ;  	(Pos2.y < Pos1.y + Size1.y))
	CMP R7,#0
	BEQ FINISH_CHECK2
	SUB R7, R7 , #1
	CMP R7 , #2
	BLE FINISH_CHECK2
	B LOOP_ARRAY_HORIZONTAL_COLLISION2
	

FINISH_INT
	B FINISH_CHECK2

LOOP_VERTICAL_ARRAY_FOR_COLLISION2
	LDR R7 , =VERTICAL_TRAIL_COUNT
	LDRH R7, [R7]
	CMP R7, #0
	BEQ FINISH_CHECK2
	
	
	
	LDR R8, =TRAILS_VERTICAL_X
	LDR R9, =TRAILS_VERTICAL_Y

LOOP_ARRAY_VERTICAL_COLLISION2 
	LDRH	R10, [R8], #2    ;R10 -> X OF TRAIL
	LDRH 	R11, [R9], #2	 ;R11 -> Y OF TRAIL 
	; CHECK FOR COLLISON
	;POS1.X ->R0
	; POS1.Y -> R1
	; POS2.X -> R10
	; POS2.Y -> R11
	; SIZE1.X -> 16
	; SIZE1.Y -> 12
	;SIZE 2.X -> 4
	;SIZE2.Y -> 5
	;    if ((Pos1.x < Pos2.x + Size2.x) &&
    ;   (Pos1.y < Pos2.y + Size2.y) &&
    ;  	(Pos2.x < Pos1.x + Size1.x) &&
    ;  	(Pos2.y < Pos1.y + Size1.y))
	ADD R5 , R10 , #4
	CMP R0 , R5
	BGT NO_COLLISION_VERTICAL2
	ADD R5 , R11, #5
	CMP R1 , R5
	BGT NO_COLLISION_VERTICAL2
	ADD R5 , R0 , #16
	CMP R10 , R5
	BGT NO_COLLISION_VERTICAL2
	ADD R5 , R1 , #12
	CMP R11 , R5
	BGT NO_COLLISION_VERTICAL2
	
	
	LDR R0 , =COMP_COLLIDED
	MOV R1, #1
	LDR R1 , [R0]
	B COLLISION_VERTICAL
	
	;-------------------
NO_COLLISION_VERTICAL2
	
	CMP R7, #0
	BEQ FINISH_CHECK2
	SUB R7, R7 , #1
	CMP R7 , #2
	BLE FINISH_CHECK2
	B LOOP_ARRAY_VERTICAL_COLLISION2
	
	
	
;------------------------------------------------------------------------------------
;------------------------------------------------------------------------------------
;------------------------------------------------------------------------------------
;------------------------------------------------------------------------------------

	LDR	R5, =COMP_CAR_X
	LDRH	R0, [R5]
	
	LDR R5, =COMP_CAR_Y
	LDRH	R1, [R5]
	
	LDR	R5, =MAIN_CAR_X
	LDRH	R10, [R5]
	
	LDR R5, =MAIN_CAR_Y
	LDRH	R11, [R5]
	
	
	ADD R5 , R10 , #16
	CMP R0 , R5
	BGT FINISH_CHECK2
	ADD R5 , R11, #16
	CMP R1 , R5
	BGT FINISH_CHECK2
	ADD R5 , R0 , #16
	CMP R10 , R5
	BGT FINISH_CHECK2
	ADD R5 , R1 , #16
	CMP R11 , R5
	BGT FINISH_CHECK2
	
	LDR R0 , =COMP_COLLIDED
	MOV R1, #1
	LDR R1 , [R0]
	LDR R0 , =MAIN_COLLIDED
	MOV R1, #1
	LDR R1 , [R0]
	B COLLISION_VERTICAL
	
	
	
	
	
COLLISION_HORIZONTAL
	BL DELAY_1_SEC
	BL DELAY_1_SEC

COLLISION_VERTICAL
	BL DELAY_1_SEC
	BL DELAY_1_SEC
	
FINISH_CHECK2
	pop {R0-R12,PC}
	ENDFUNC
	
	
;##################################################################################################################################################################
MAIN_CHECK_COLLISION FUNCTION
	PUSH {R0,R1,LR}
	LDR R0,=MAIN_COLLIDED
	LDRH R1,[R0]
	CMP R1,#1
	BEQ MC_NOT_COLLIDED
	LDR R0,=COMP_COLLIDED
	LDRH R1,[R0]
	CMP R1,#1
	BEQ MC_NOT_COLLIDED
	B NO_GAME_OVER
MC_NOT_COLLIDED
	BL GAMEOVER
NO_GAME_OVER
	POP {R0,R1,PC}
	ENDFUNC

;##################################################################################################################################################################

NEON_RACERS FUNCTION
	PUSH{R0-R12,LR}
	
	BL DRAW_BACKGROUND
	;MAIN_CAR_X	DCW		0x70 ; 112h
	;MAIN_CAR_Y	DCW		0xA0 ; 160h
	LDR R6, =MAIN_CAR_X
	LDR R7, =MAIN_CAR_Y
	MOV R0, #112
	MOV R1, #0xA0
	STRH R0, [R6]
	STRH R1, [R7]
	LDR R6, =COMP_CAR_X
	LDR R7, =COMP_CAR_Y
	MOV R0, #368
	MOV R1, #0xA0
	STRH R0, [R6]
	STRH R1, [R7]
	
	;INITIALIZE ORIENTATIONS

	MOV R8 ,#0 ; BLUE CAR
	BL DRAW_MAIN_CAR_RIGHT
	MOV R8, #1 ; RED CAR
	BL DRAW_MAIN_CAR_LEFT
	LDR R6, =ORIENTATION_MAIN
	LDR R7, =ORIENTATION_COMP
	MOV R0, #2
	STRH R0, [R6]
	MOV R0,#4
	STRH R0,[R7]
	B SKIP_THIS_LINE4
	LTORG
SKIP_THIS_LINE4

MAIN_GAME_LOOP
	BL	TRAIL_COLLISION
	BL 	MAIN_CHECK_COLLISION
	BL CHECK_INPUT
	
;;;;;;;;;;;;;;;;;;;;;;;;;;;; BLUE CAR
	MOV R8, #0
	LDR R11,=ORIENTATION_MAIN
	LDRH R10,[R11]
	CMP R10, #1
	BNE SKIP_UP13
	BL MOVE_MAIN_CAR_UP
SKIP_UP13
	CMP R10, #2
	BNE SKIP_RIGHT
	BL MOVE_MAIN_CAR_RIGHT
SKIP_RIGHT13
	CMP R10,#3
	BNE SKIP_DOWN13
	BL MOVE_MAIN_CAR_DOWN
SKIP_DOWN13
	CMP R10, #4
	BNE SKIP_LEFT13
	BL MOVE_MAIN_CAR_LEFT
SKIP_LEFT13
	BL DELAY_10_MILLI_SEC
	
	
;---------------------------REDCAR
	
	LDR R11,=ORIENTATION_COMP
	LDRH R10,[R11]
	CMP R10, #1
	BNE SKIP_UP12
	BL MOVE_COMP_CAR_UP
SKIP_UP12
	CMP R10, #2
	BNE SKIP_RIGHT12
	BL MOVE_COMP_CAR_RIGHT
SKIP_RIGHT12
	CMP R10,#3
	BNE SKIP_DOWN12
	BL MOVE_COMP_CAR_DOWN
SKIP_DOWN12
	CMP R10, #4
	BNE SKIP_LEFT12
	BL MOVE_COMP_CAR_LEFT
SKIP_LEFT12
	BL DELAY_10_MILLI_SEC
	
	
	LDR R0,=GAMEOVERFLAG
	LDR R0,[R0]
	CMP R0,#1
	BEQ BIGLOOP
	B MAIN_GAME_LOOP
	
	
	
	
	
	
	
	POP{R0-R12,PC}
	
	ENDFUNC
	
;###############################################################################################################


MOVE_MAIN_CAR_RIGHT	FUNCTION
	PUSH{R0-R12,LR}


	
	ldr		r1, =MAIN_CAR_X
	ldrh	r0, [r1]
	add		r0, r0, #5
	
	B SKIP81Y4KFJF
	LTORG
SKIP81Y4KFJF

	mov 	r6, #0xFFFF
	and		r6, r6, r0
	add 	r6,r6,#16
	mov 	r7, #480
	cmp		r6, r7	
	bge		lolx
	
	strh	r0, [r1]
	push {R0-R12}
	
	
	ldr		r5, =MAIN_CAR_X
	ldrh		r5, [r5]
	mov		r0, r5
	
	sub		r0, r0, #5
	
	ldr		r5, =MAIN_CAR_Y
	ldrh		r5, [r5]
	mov		r1, r5
	
	;X1 = [] r0
	;Y1 = [] r1
	;X2 = [] r3
	;Y2 = [] r4
	mov		r6, #16
	MOV 	R7, #12
	add		r3, r0, r6
	add		r4, r1, R7
	
	mov		r10, #BLACK
	bl		DRAW_RECTANGLE_FILLED
	bl DRAW_TRAIL_RIGHT
	
	pop {R0-R12}
	bl	DRAW_MAIN_CAR_RIGHT
	B LOLX11
lolx
	LDR R0 , =MAIN_COLLIDED
	MOV R1, #1
	LDR R1 , [R0]
LOLX11
	
	POP{R0-R12,PC}
	ENDFUNC

;##################################################################
MOVE_MAIN_CAR_LEFT	FUNCTION
	PUSH{R0-R12,LR}
	;TODO: CHECK FOR SCREEN BOUNDARIES, IF THE SPRITE TOUCHES A WALL, DON'T MOVE
	
	;TODO: COVER THE SPIRIT WITH THE BACKGROUND COLOR
	
	;TODO: REDRAW THE SPIRIT IN THE NEW COORDINATES AND UPDATE ITS COORDINATES IN THE DATASECTION

	
	ldr		r1, =MAIN_CAR_X
	ldrh	r0, [r1]
	SUB		r0, r0, #5
	
	mov 	r6, #0xFFFF
	and		r6, r6, r0
	mov 	r7, #16
	cmp		R7,R6	
	bge		lolx2
	
	strh	r0, [r1]
	push {R0-R12}
	
	
	ldr		r5, =MAIN_CAR_X
	ldrh		r5, [r5]
	mov		r0, r5
	
	ADD	r0, r0, #5
	
	ldr		r5, =MAIN_CAR_Y
	ldrh		r5, [r5]
	mov		r1, r5
	
	;X1 = [] r0
	;Y1 = [] r1
	;X2 = [] r3
	;Y2 = [] r4
	mov		r6, #16
	MOV 	R7, #12
	add		r3, r0, r6
	add		r4, r1, R7
	
	mov		r10, #BLACK
	bl		DRAW_RECTANGLE_FILLED
	bl DRAW_TRAIL_LEFT
	
	pop {R0-R12}
	bl	DRAW_MAIN_CAR_LEFT
	B LOLX21
lolx2
	LDR R0 , =MAIN_COLLIDED
	MOV R1, #1
	LDR R1 , [R0]
LOLX21
	POP{R0-R12,PC}
	ENDFUNC

;##################################################################
MOVE_MAIN_CAR_DOWN	FUNCTION
	PUSH{R0-R12,LR}
	;TODO: CHECK FOR SCREEN BOUNDARIES, IF THE SPRITE TOUCHES A WALL, DON'T MOVE
	
	;TODO: COVER THE SPIRIT WITH THE BACKGROUND COLOR
	
	;TODO: REDRAW THE SPIRIT IN THE NEW COORDINATES AND UPDATE ITS COORDINATES IN THE DATASECTION

	
	ldr		r1, =MAIN_CAR_Y
	ldrh	r0, [r1]
	add		r0, r0, #5
	
	mov 	r6, #0xFFFF
	and		r6, r6, r0
	add 	r6,r6,#16
	mov 	r7, #320
	cmp		r6, r7	
	bge		lolx3
	
	strh	r0, [r1]
	push {R0-R12}
	
	
	ldr		r5, =MAIN_CAR_Y
	ldrh		r5, [r5]
	mov		r0, r5
	
	sub		r0, r0, #5
	
	ldr		r5, =MAIN_CAR_X
	ldrh		r5, [r5]
	mov		r1, r5
	
	;X1 = [] r0
	;Y1 = [] r1
	;X2 = [] r3
	;Y2 = [] r4
	;Exchange r0 and r1 
	
	mov r11, r0
	mov r0,r1
	mov r1, r11
	
	mov		r6, #12
	MOV 	R7, #16
	add		r3, r0, r6
	add		r4, r1, R7
	mov		r10, #BLACK
	bl		DRAW_RECTANGLE_FILLED
	bl 		DRAW_TRAIL_DOWN
	
	pop {R0-R12}
	bl	DRAW_MAIN_CAR_DOWN
	B LOLX31
lolx3
	LDR R0 , =MAIN_COLLIDED
	MOV R1, #1
	LDR R1 , [R0]
LOLX31
	
	POP{R0-R12,PC}
	ENDFUNC

;##################################################################
;##################################################################

DRAW_BACKGROUND FUNCTION
	PUSH{R0-R12,LR}
	
	MOV R0, #0
	MOV R1, #0
	MOV R3, #480
	MOV R4, #320
	MOV R10, #0x0000
	BL DRAW_RECTANGLE_FILLED_A
	
	
	POP{R0-R12,PC}
	ENDFUNC
;##########################################################3333
MOVE_COMP_CAR_RIGHT	FUNCTION
	PUSH{R0-R12,LR}


	
	ldr		r1, =COMP_CAR_X
	ldrh	r0, [r1]
	add		r0, r0, #5
	
	
	mov 	r6, #0xFFFF
	and		r6, r6, r0
	add 	r6,r6,#16
	mov 	r7, #480
	cmp		r6, r7	
	bge		loly
	
	strh	r0, [r1]
	push {R0-R12}
	
	
	ldr		r5, =COMP_CAR_X
	ldrh		r5, [r5]
	mov		r0, r5
	
	sub		r0, r0, #5
	
	ldr		r5, =COMP_CAR_Y
	ldrh		r5, [r5]
	mov		r1, r5
	
	;X1 = [] r0
	;Y1 = [] r1
	;X2 = [] r3
	;Y2 = [] r4
	mov		r6, #16
	MOV 	R7, #12
	add		r3, r0, r6
	add		r4, r1, R7
	
	mov		r10, #BLACK
	bl		DRAW_RECTANGLE_FILLED
	MOV R8, #1
	bl DRAW_TRAIL_RIGHT
	
	pop {R0-R12}
	MOV R8, #1
	bl	DRAW_MAIN_CAR_RIGHT
	B LOLY11
loly
	LDR R0 , =COMP_COLLIDED
	MOV R1, #1
	LDR R1 , [R0]
LOLY11
	
	POP{R0-R12,PC}
	ENDFUNC

;##################################################################
MOVE_COMP_CAR_LEFT	FUNCTION
	PUSH{R0-R12,LR}


	
	ldr		r1, =COMP_CAR_X
	ldrh	r0, [r1]
	SUB		r0, r0, #5
	
	mov 	r6, #0xFFFF
	and		r6, r6, r0
	mov 	r7, #16
	cmp		R7,R6	
	bge		loly2
	
	strh	r0, [r1]
	push {R0-R12}
	
	
	ldr		r5, =COMP_CAR_X
	ldrh		r5, [r5]
	mov		r0, r5
	
	ADD	r0, r0, #5
	
	ldr		r5, =COMP_CAR_Y
	ldrh		r5, [r5]
	mov		r1, r5
	
	;X1 = [] r0
	;Y1 = [] r1
	;X2 = [] r3
	;Y2 = [] r4
	mov		r6, #16
	MOV 	R7, #12
	add		r3, r0, r6
	add		r4, r1, R7
	
	mov		r10, #BLACK
	bl		DRAW_RECTANGLE_FILLED
	MOV R8, #1
	bl DRAW_TRAIL_LEFT
	
	pop {R0-R12}
	MOV R8, #1
	bl	DRAW_MAIN_CAR_LEFT
	B LOLY22
loly2
	LDR R0 , =COMP_COLLIDED
	MOV R1, #1
	LDR R1 , [R0]
LOLY22
	POP{R0-R12,PC}
	ENDFUNC

;##################################################################
MOVE_COMP_CAR_DOWN	FUNCTION
	PUSH{R0-R12,LR}


	
	ldr		r1, =COMP_CAR_Y
	ldrh	r0, [r1]
	add		r0, r0, #5
	
	mov 	r6, #0xFFFF
	and		r6, r6, r0
	add 	r6,r6,#16
	mov 	r7, #320
	cmp		r6, r7	
	bge		loly3
	
	strh	r0, [r1]
	push {R0-R12}
	
	
	ldr		r5, =COMP_CAR_Y
	ldrh		r5, [r5]
	mov		r0, r5
	
	sub		r0, r0, #5
	
	ldr		r5, =COMP_CAR_X
	ldrh		r5, [r5]
	mov		r1, r5
	
	;X1 = [] r0
	;Y1 = [] r1
	;X2 = [] r3
	;Y2 = [] r4
	;Exchange r0 and r1 
	
	mov r11, r0
	mov r0,r1
	mov r1, r11
	
	mov		r6, #12
	MOV 	R7, #16
	add		r3, r0, r6
	add		r4, r1, R7
	mov		r10, #BLACK
	bl		DRAW_RECTANGLE_FILLED
	MOV R8, #1
	bl 		DRAW_TRAIL_DOWN
	
	pop {R0-R12}
	MOV R8, #1
	bl	DRAW_MAIN_CAR_DOWN
	B LOLY33
loly3
	LDR R0 , =COMP_COLLIDED
	MOV R1, #1
	LDR R1 , [R0]
LOLY33
	
	POP{R0-R12,PC}
	ENDFUNC

;##################################################################

DRAW_MAIN_CAR_UP FUNCTION
	;THIS FUNCTION TAKES STARTING X AND STARTING Y THEN DRAWS AN IMAGE
	;ARGUMENTS: R0 = X, R1 = Y
	PUSH{R0-R12, LR}
	CMP R8,#0
	BEQ CAR1UP
	B	CAR2UP
CAR1UP
	LDR R6, =MAIN_CAR_X
	LDR R7, =MAIN_CAR_Y
	LDR R5, =NEON_CAR_MAIN_FRONT
	B CAR3UP
CAR2UP
	LDR R6, =COMP_CAR_X
	LDR R7, =COMP_CAR_Y
	LDR R5, =NEON_CAR_COMP_FRONT
	
	

CAR3UP

	LDR R0, [R6]
	LDR R1, [R7]
	MOV R3, R1
;	ADD R1, R0, #38
;	ADD R4, R3, #46 ;I KNOW THE HEIGHT IS MORE THAN THE IMAGE, BUT THE EXTRA HEIGHT IS JUST A SAFE MEASURE TO AVOID OVERLAPPING, THE WIDTH SHOULD STRICTLY BE THE SAME AS YOUR PICTURE.

	ADD R1, R0, #11
	ADD R4, R3, #16 ;I KNOW THE HEIGHT IS MORE THAN THE IMAGE, BUT THE EXTRA HEIGHT IS JUST A SAFE MEASURE TO AVOID OVERLAPPING, THE WIDTH SHOULD STRICTLY BE THE SAME AS YOUR PICTURE.

	BL ADDRESS_SET

	MOV R7, #192 ;-AREA OF THE PHOTO, 12 X 16


	;MEMORY WRITE
	MOV R2, #0x2C
	BL LCD_COMMAND_WRITE
IMAGE_LOOP61
	LDR R6, [R5], #2	;POST INCREMENT
	MOV R2, R6
	BL LCD_16_DATA_WRITE
	B SKIPAKUGFIAUGY
	LTORG
SKIPAKUGFIAUGY
	SUB R7, R7, #1
	CMP R7, #0
	BGT IMAGE_LOOP61

	POP {R0-R12, PC}

	ENDFUNC


;##################################################################
DRAW_MAIN_CAR_RIGHT FUNCTION
	;THIS FUNCTION TAKES STARTING X AND STARTING Y THEN DRAWS AN IMAGE
	;ARGUMENTS: R0 = X, R1 = Y
	;MAIN_CAR_X	DCW		0x70 ; 112h
	;MAIN_CAR_Y	DCW		0xA0 ; 160h
	PUSH{R0-R12, LR}
	CMP R8,#0
	BEQ CAR1RIGHT
	B	CAR2RIGHT
CAR1RIGHT
	LDR R6, =MAIN_CAR_X
	LDR R7, =MAIN_CAR_Y
	LDR R5, =NEON_CAR_MAIN_RIGHT
	B CAR3RIGHT
CAR2RIGHT
	LDR R6, =COMP_CAR_X
	LDR R7, =COMP_CAR_Y
	LDR R5, =NEON_CAR_COMP_RIGHT
	
	B SKIPFAKUFFA
	LTORG
SKIPFAKUFFA

CAR3RIGHT
	LDR R0, [R6]
	LDR R1, [R7]
	MOV R3, R1
;	ADD R1, R0, #38
;	ADD R4, R3, #46 ;I KNOW THE HEIGHT IS MORE THAN THE IMAGE, BUT THE EXTRA HEIGHT IS JUST A SAFE MEASURE TO AVOID OVERLAPPING, THE WIDTH SHOULD STRICTLY BE THE SAME AS YOUR PICTURE.

	ADD R1, R0, #15
	ADD R4, R3, #12 ;I KNOW THE HEIGHT IS MORE THAN THE IMAGE, BUT THE EXTRA HEIGHT IS JUST A SAFE MEASURE TO AVOID OVERLAPPING, THE WIDTH SHOULD STRICTLY BE THE SAME AS YOUR PICTURE.

	BL ADDRESS_SET

	MOV R7, #192 ;-AREA OF THE PHOTO, 12 X 16
	;;


	;MEMORY WRITE
	MOV R2, #0x2C
	BL LCD_COMMAND_WRITE
IMAGE_LOOP71
	LDR R6, [R5], #2	;POST INCREMENT
	MOV R2, R6
	BL LCD_16_DATA_WRITE
	SUB R7, R7, #1
	CMP R7, #0
	BGT IMAGE_LOOP71

	POP {R0-R12, PC}

	ENDFUNC

	B SKIP81Y4KFJFG
	LTORG
SKIP81Y4KFJFG
;##################################################################
DRAW_MAIN_CAR_LEFT FUNCTION
	;THIS FUNCTION TAKES STARTING X AND STARTING Y THEN DRAWS AN IMAGE
	;ARGUMENTS: R0 = X, R1 = Y
	PUSH{R0-R12, LR}
	CMP R8,#0
	BEQ CAR1LEFT
	B	CAR2LEFT
CAR1LEFT
	LDR R6, =MAIN_CAR_X
	LDR R7, =MAIN_CAR_Y
	LDR R5, =NEON_CAR_MAIN_LEFT
	B CAR3LEFT
CAR2LEFT
	LDR R6, =COMP_CAR_X
	LDR R7, =COMP_CAR_Y
	LDR R5, =NEON_CAR_COMP_LEFT
	
	

CAR3LEFT

	LDR R0, [R6]
	LDR R1, [R7]
	MOV R3, R1
;	ADD R1, R0, #38
;	ADD R4, R3, #46 ;I KNOW THE HEIGHT IS MORE THAN THE IMAGE, BUT THE EXTRA HEIGHT IS JUST A SAFE MEASURE TO AVOID OVERLAPPING, THE WIDTH SHOULD STRICTLY BE THE SAME AS YOUR PICTURE.

	ADD R1, R0, #15
	ADD R4, R3, #12 ;I KNOW THE HEIGHT IS MORE THAN THE IMAGE, BUT THE EXTRA HEIGHT IS JUST A SAFE MEASURE TO AVOID OVERLAPPING, THE WIDTH SHOULD STRICTLY BE THE SAME AS YOUR PICTURE.

	BL ADDRESS_SET

	MOV R7, #192 ;-AREA OF THE PHOTO, 12 X 16

	;MEMORY WRITE
	MOV R2, #0x2C
	BL LCD_COMMAND_WRITE
IMAGE_LOOP8
	LDR R6, [R5], #2	;POST INCREMENT
	MOV R2, R6
	BL LCD_16_DATA_WRITE
	SUB R7, R7, #1
	CMP R7, #0
	BGT IMAGE_LOOP8

	POP {R0-R12, PC}

	ENDFUNC


;##################################################################
DRAW_MAIN_CAR_DOWN FUNCTION
	;THIS FUNCTION TAKES STARTING X AND STARTING Y THEN DRAWS AN IMAGE
	;ARGUMENTS: R0 = X, R1 = Y
	PUSH{R0-R12, LR}
	CMP R8,#0
	BEQ CAR1DOWN
	B	CAR2DOWN
CAR1DOWN
	LDR R6, =MAIN_CAR_X
	LDR R7, =MAIN_CAR_Y
	LDR R5, =NEON_CAR_MAIN_DOWN
	B CAR3DOWN
CAR2DOWN
	LDR R6, =COMP_CAR_X
	LDR R7, =COMP_CAR_Y
	LDR R5, =NEON_CAR_COMP_DOWN
	
	

CAR3DOWN

	LDR R0, [R6]
	LDR R1, [R7]
	MOV R3, R1
;	ADD R1, R0, #38
;	ADD R4, R3, #46 ;I KNOW THE HEIGHT IS MORE THAN THE IMAGE, BUT THE EXTRA HEIGHT IS JUST A SAFE MEASURE TO AVOID OVERLAPPING, THE WIDTH SHOULD STRICTLY BE THE SAME AS YOUR PICTURE.

	ADD R1, R0, #11
	ADD R4, R3, #16 ;I KNOW THE HEIGHT IS MORE THAN THE IMAGE, BUT THE EXTRA HEIGHT IS JUST A SAFE MEASURE TO AVOID OVERLAPPING, THE WIDTH SHOULD STRICTLY BE THE SAME AS YOUR PICTURE.

	BL ADDRESS_SET

	MOV R7, #192 ;-AREA OF THE PHOTO, 12 X 16


	;MEMORY WRITE
	MOV R2, #0x2C
	BL LCD_COMMAND_WRITE
IMAGE_LOOP9
	LDR R6, [R5], #2	;POST INCREMENT
	MOV R2, R6
	BL LCD_16_DATA_WRITE
	SUB R7, R7, #1
	CMP R7, #0
	BGT IMAGE_LOOP9

	POP {R0-R12, PC}

	ENDFUNC


;##################################################################
DRAW_TRAIL_RIGHT FUNCTION
	PUSH{R0-R12,LR}
	MOV R9 ,R8
	add		r1, r1, #4 ;Changes Y1 and Y2
	sub		r4, r4, #4
	
	MOV 	R3,	R0
	ADD		R3,	R3,	#5 ;X2 = X1+5
	
	;Store the value of X1 inside the Trails_horizontal arrays
	mov		r5, r0  ;copies the value of X1 to r5
	ldr		r6, =TRAILS_HORIZONTAL_X
	
	ldr		r2, =HORIZONTAL_TRAIL_COUNT
	ldrh	r8, [r2] ;hold the vertical trail count

	lsl		r7, r8, #1 ;multiplies count by 2 because r6 + 2xcount = the current end of the array
	add		r6, r6, r7
	strh	r5, [r6] ;stores the x value inside the array
	
	;Store the value of Y1 inside the Trails_horizontal arrays
	mov		r5, r1  ;copies the value of Y1 to r5
	ldr		r6, =TRAILS_HORIZONTAL_Y
	
	add		r6, r6, r7
	strh	r5, [r6] ;stores the y value inside the array
	
	add		r8, r8, #1 ;Increments the vertical count by one
	strh	r8, [r2]   ;Stores the new count in the memory
	
	CMP R9, #1
	BEQ RED_CAR_TRAIL_RIGHT1
	mov		r10, #BLUE_TRAIL
	B TRAIL_RIGHT
RED_CAR_TRAIL_RIGHT1
	MOV R10, #RED_TRAIL
TRAIL_RIGHT
	bl		DRAW_RECTANGLE_FILLED ;Draws the blue part of the trail
	
	add		r1, r1, #1
	sub		r4, r4, #1
	
	CMP R9, #1
	BEQ RED_CAR_TRAIL_RIGHT2
	mov		r10, #CYAN_TRAIL
	B TRAIL_RIGHT2
RED_CAR_TRAIL_RIGHT2
	MOV R10, #RED_TRAIL2
TRAIL_RIGHT2

	bl		DRAW_RECTANGLE_FILLED ;Draws the cyan part of the trail
	pop {R0-R12,PC}
	ENDFUNC
;######################################################################
DRAW_TRAIL_DOWN FUNCTION
	PUSH{R0-R12,LR}
	MOV R9,R8
	add		r0, r0, #4	;Changes X1 and X2
	sub		r3, r3, #4
	
	MOV 	R4,	R1
	ADD		R4,	R4,	#5 ;Y2 = Y1 + 5
	
	;Store the value of X1 inside the Trails_vertical arrays
	mov		r5, r0  ;copies the value of X1 to r5
	ldr		r6, =TRAILS_VERTICAL_X
	
	ldr		r2, =VERTICAL_TRAIL_COUNT
	ldrh		r8, [r2] ;hold the vertical trail count

	lsl		r7, r8, #1 ;multiplies count by 2 because r6 + 2xcount = the current end of the array
	add		r6, r6, r7
	strh	r5, [r6] ;stores the x value inside the array
	
;Store the value of Y1 inside the Trails_vertical arrays
	mov		r5, r1  ;copies the value of Y1 to r5
	ldr		r6, =TRAILS_VERTICAL_Y
	
	add		r6, r6, r7
	strh	r5, [r6] ;stores the y value inside the array
	
	add		r8, r8, #1 ;Increments the vertical count by one
	strh	r8, [r2]   ;Stores the new count in the memory

	CMP R9, #1
	BEQ RED_CAR_TRAIL_DOWN1
	mov		r10, #BLUE_TRAIL
	B TRAIL_DOWN
RED_CAR_TRAIL_DOWN1
	MOV R10, #RED_TRAIL
TRAIL_DOWN



	bl		DRAW_RECTANGLE_FILLED ;Draws the blue part of the trail
	
	add		r0, r0, #1
	sub		r3, r3, #1

	CMP R9, #1
	BEQ RED_CAR_TRAIL_DOWN2
	mov		r10, #CYAN_TRAIL
	B TRAIL_DOWN2
RED_CAR_TRAIL_DOWN2
	MOV R10, #RED_TRAIL2
TRAIL_DOWN2






	bl		DRAW_RECTANGLE_FILLED ;Draws the cyan part of the trail
	pop {R0-R12,PC}
	ENDFUNC

DRAW_TRAIL_LEFT FUNCTION
	PUSH{R0-R12,LR}
	MOV R9,R8
	add		r1, r1, #4 ;Changes Y1 and Y2
	sub		r4, r4, #4
	
	ADD 	R0, R0,#16
	MOV 	R3,	R0
	ADD		R3,	R3,	#5 ;X2 = X1+5
	
	;Store the value of X1 inside the Trails_horizontal arrays
	mov		r5, r0  ;copies the value of X1 to r5
	ldr		r6, =TRAILS_HORIZONTAL_X
	
	ldr		r2, =HORIZONTAL_TRAIL_COUNT
	ldrh		r8, [r2] ;hold the vertical trail count

	lsl		r7, r8, #1 ;multiplies count by 2 because r6 + 2xcount = the current end of the array
	add		r6, r6, r7
	strh	r5, [r6] ;stores the x value inside the array
	
	;Store the value of Y1 inside the Trails_horizontal arrays
	mov		r5, r1  ;copies the value of Y1 to r5
	ldr		r6, =TRAILS_HORIZONTAL_Y
	
	add		r6, r6, r7
	strh	r5, [r6] ;stores the y value inside the array
	
	add		r8, r8, #1 ;Increments the vertical count by one
	strh	r8, [r2]   ;Stores the new count in the memory
	
	CMP R9, #1
	BEQ RED_CAR_TRAIL_LEFT1
	mov		r10, #BLUE_TRAIL
	B TRAIL_LEFT
RED_CAR_TRAIL_LEFT1
	MOV R10, #RED_TRAIL
TRAIL_LEFT



	bl		DRAW_RECTANGLE_FILLED ;Draws the blue part of the trail
	
	add		r1, r1, #1
	sub		r4, r4, #1

	CMP R9, #1
	BEQ RED_CAR_TRAIL_LEFT2
	mov		r10, #CYAN_TRAIL
	B TRAIL_LEFT2
RED_CAR_TRAIL_LEFT2
	MOV R10, #RED_TRAIL2
TRAIL_LEFT2

	bl		DRAW_RECTANGLE_FILLED ;Draws the cyan part of the trail
	pop {R0-R12,PC}
	ENDFUNC
	
DRAW_TRAIL_UP FUNCTION
	PUSH{R0-R12,LR}
	MOV R9, R8
	add		r0, r0, #4	;Changes X1 and X2
	sub		r3, r3, #4
	
	ADD		R1,R1,#16
	MOV 	R4,	R1
	ADD		R4,	R4,	#5 ;Y2 = Y1 + 5
	
	;Store the value of X1 inside the Trails_vertical arrays
	mov		r5, r0  ;copies the value of X1 to r5
	ldr		r6, =TRAILS_VERTICAL_X
	
	ldr		r2, =VERTICAL_TRAIL_COUNT
	ldrh		r8, [r2] ;hold the vertical trail count

	lsl		r7, r8, #1 ;multiplies count by 2 because r6 + 2xcount = the current end of the array
	add		r6, r6, r7
	strh	r5, [r6] ;stores the x value inside the array
	
;Store the value of Y1 inside the Trails_vertical arrays
	mov		r5, r1  ;copies the value of Y1 to r5
	ldr		r6, =TRAILS_VERTICAL_Y
	
	add		r6, r6, r7
	strh	r5, [r6] ;stores the y value inside the array
	
	add		r8, r8, #1 ;Increments the vertical count by one
	strh	r8, [r2]   ;Stores the new count in the memory
	
	CMP R9, #1
	BEQ RED_CAR_TRAIL_UP1
	mov		r10, #BLUE_TRAIL
	B TRAIL_UP
RED_CAR_TRAIL_UP1
	MOV R10, #RED_TRAIL
TRAIL_UP


	bl		DRAW_RECTANGLE_FILLED ;Draws the blue part of the trail
	
	add		r0, r0, #1
	sub		r3, r3, #1
	
	
	CMP R9, #1
	BEQ RED_CAR_TRAIL_UP2
	mov		r10, #CYAN_TRAIL
	B TRAIL_UP2
RED_CAR_TRAIL_UP2
	MOV R10, #RED_TRAIL2
TRAIL_UP2

	bl		DRAW_RECTANGLE_FILLED ;Draws the cyan part of the trail
	pop {R0-R12,PC}
	ENDFUNC

CHECK_INPUT FUNCTION
	PUSH{R0-R12,LR}
	;UP B14
	;DOWN B13
	;RIGHT B12
	;LEFT B10
	
	;GET ORIENTATION
	LDR R11,=ORIENTATION_MAIN
	LDRH R10,[R11]
	
	
	;CHECK FOR UP
	LDR R9,=GPIOB_IDR
	LDR R8,[R9]
	AND R8,#0x4000
	CMP R8,#0
	BNE NEXT1
	CMP R10,#3
	BEQ OVER
	PUSH{R0,R1}
	LDR R0, =MAIN_CAR_X
	LDRH R1,[R0]
	ADD R1, R1, #1
	STRH R1, [R0]
	POP{R0,R1}
	MOV R10, #1
	B OVER
	
NEXT1	;DOWN
	LDR R8,[R9]
	AND R8,#0x2000
	CMP R8,#0
	BNE NEXT2
	CMP R10,#1
	BEQ OVER
	PUSH{R0,R1}
	LDR R0, =MAIN_CAR_X
	LDRH R1,[R0]
	ADD R1, R1, #1
	STRH R1, [R0]
	POP{R0,R1}
	MOV R10, #3
	B OVER
NEXT2 ;RIGHT
	LDR R8,[R9]
	AND R8,#0x1000
	CMP R8,#0
	BNE NEXT3
	CMP R10,#4
	BEQ OVER
	PUSH{R0,R1}
	LDR R0, =MAIN_CAR_Y
	LDRH R1,[R0]
	ADD R1, R1, #2
	B SKIP581Y4KFJF
	LTORG
SKIP581Y4KFJF
	STRH R1, [R0]
	POP{R0,R1}
	MOV R10, #2
	B OVER
NEXT3 ;LEFT
	LDR R8,[R9]
	AND R8, #0x400
	CMP R8,#0
	BNE NEXT4
	CMP R10,#2
	BEQ OVER
	PUSH{R0,R1}
	LDR R0, =MAIN_CAR_Y
	LDRH R1,[R0]
	SUB	R1, R1, #2
	STRH R1, [R0]
	POP{R0,R1}
	MOV R10, #4
	B OVER
NEXT4

OVER
	STRH R10 , [R11]

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	;UP 	B15
	;DOWN 	B9
	;RIGHT 	B8
	;LEFT 	C15
	
	LDR R11,=ORIENTATION_COMP
	LDRH R10,[R11]
	;CHECK FOR UP
	LDR R9,=GPIOB_IDR
	LDR R8,[R9]
	AND R8, #0x8000
	CMP R8,#0
	BNE NEXT11
	CMP R10,#3
	BEQ OVER2
	PUSH{R0,R1}
	LDR R0, =COMP_CAR_X
	LDRH R1,[R0]
	ADD R1, R1, #1
	STRH R1, [R0]
	POP{R0,R1}
	MOV R10, #1
	B OVER2
	
NEXT11	;DOWN
	LDR R8,[R9]
	AND R8, #0x200
	CMP R8,#0
	BNE NEXT22
	CMP R10,#1
	BEQ OVER2
	PUSH{R0,R1}
	LDR R0, =COMP_CAR_X
	LDRH R1,[R0]
	ADD R1, R1, #1
	STRH R1, [R0]
	POP{R0,R1}
	MOV R10, #3
	B OVER2
NEXT22 ;RIGHT
	LDR R8,=GPIOC_IDR
	LDR R8 ,[R8]
	AND R8,#0x8000
	CMP R8,#0
	B NEXT33
	CMP R10,#4
	BEQ OVER2
	PUSH{R0,R1}
	LDR R0, =COMP_CAR_Y
	LDRH R1,[R0]
	ADD R1, R1, #1
	STRH R1, [R0]
	POP{R0,R1}
	MOV R10, #2
	B OVER2
NEXT33 ;LEFT
	LDR R9 , =GPIOB_IDR
	LDR R8,[R9]
	AND R8, #0x100
	CMP R8,#0
	BNE NEXT44
	CMP R10,#2
	BEQ OVER2
	PUSH{R0,R1}
	LDR R0, =COMP_CAR_Y
	LDRH R1,[R0]
	SUB R1, R1, #1
	STRH R1, [R0]
	POP{R0,R1}
	MOV R10, #4
	B OVER2
NEXT44

OVER2
	STRH R10 , [R11]
		
	
	POP{R0-R12,PC}
	
	
	ENDFUNC

DRAW_IMAGE	FUNCTION
	;THIS FUNCTION TAKES STARTING X AND STARTING Y THEN DRAWS AN IMAGE
	;ARGUMENTS: R0 = X, R1 = Y
	PUSH{R0-R7, LR}
	
	MOV R3, R1
;	ADD R1, R0, #38
;	ADD R4, R3, #46 ;I KNOW THE HEIGHT IS MORE THAN THE IMAGE, BUT THE EXTRA HEIGHT IS JUST A SAFE MEASURE TO AVOID OVERLAPPING, THE WIDTH SHOULD STRICTLY BE THE SAME AS YOUR PICTURE.

	ADD R1, R0, #99
	ADD R4, R3, #70 ;I KNOW THE HEIGHT IS MORE THAN THE IMAGE, BUT THE EXTRA HEIGHT IS JUST A SAFE MEASURE TO AVOID OVERLAPPING, THE WIDTH SHOULD STRICTLY BE THE SAME AS YOUR PICTURE.

	BL ADDRESS_SET

	MOV R7, #7000 ;AREA OF THE PHOTO, 39 X 47
;	LDR R5, =CAR1

	;MEMORY WRITE
	MOV R2, #0x2C
	BL LCD_COMMAND_WRITE
IMAGE_LOOP
	LDR R6, [R5], #2	;POST INCREMENT
	MOV R2, R6
	BL LCD_16_DATA_WRITE
	SUB R7, R7, #1
	CMP R7, #0
	BGT IMAGE_LOOP

	POP {R0-R7, PC}

	ENDFUNC

;##################################################################################################################################################################
DRAW_NEON_TITLE	FUNCTION
	;THIS FUNCTION TAKES STARTING X AND STARTING Y THEN DRAWS AN IMAGE
	;ARGUMENTS: R0 = X, R1 = Y
	PUSH{R0-R7, LR}
	
	MOV R3, R1
;	ADD R1, R0, #38
;	ADD R4, R3, #46 ;I KNOW THE HEIGHT IS MORE THAN THE IMAGE, BUT THE EXTRA HEIGHT IS JUST A SAFE MEASURE TO AVOID OVERLAPPING, THE WIDTH SHOULD STRICTLY BE THE SAME AS YOUR PICTURE.

	ADD R1, R0, #99
	ADD R4, R3, #70 ;I KNOW THE HEIGHT IS MORE THAN THE IMAGE, BUT THE EXTRA HEIGHT IS JUST A SAFE MEASURE TO AVOID OVERLAPPING, THE WIDTH SHOULD STRICTLY BE THE SAME AS YOUR PICTURE.

	BL ADDRESS_SET

	MOV R7, #7000 ;-AREA OF THE PHOTO, 39 X 47
	LDR R5, =NEON_TITLE

	;MEMORY WRITE
	MOV R2, #0x2C
	BL LCD_COMMAND_WRITE
IMAGE_LOOP4
	LDR R6, [R5], #2	;POST INCREMENT
	MOV R2, R6
	BL LCD_16_DATA_WRITE
	SUB R7, R7, #1
	CMP R7, #0
	BGT IMAGE_LOOP4

	POP {R0-R7, PC}

	ENDFUNC
;##################################################################################################################################################################

;##################################################################################################################################################################
DRAW_NEON_START	FUNCTION
	;THIS FUNCTION TAKES STARTING X AND STARTING Y THEN DRAWS AN IMAGE
	;ARGUMENTS: R0 = X, R1 = Y
	PUSH{R0-R7, LR}
	
	MOV R3, R1
;	ADD R1, R0, #38
;	ADD R4, R3, #46 ;I KNOW THE HEIGHT IS MORE THAN THE IMAGE, BUT THE EXTRA HEIGHT IS JUST A SAFE MEASURE TO AVOID OVERLAPPING, THE WIDTH SHOULD STRICTLY BE THE SAME AS YOUR PICTURE.

	ADD R1, R0, #51
	ADD R4, R3, #12 ;I KNOW THE HEIGHT IS MORE THAN THE IMAGE, BUT THE EXTRA HEIGHT IS JUST A SAFE MEASURE TO AVOID OVERLAPPING, THE WIDTH SHOULD STRICTLY BE THE SAME AS YOUR PICTURE.

	BL ADDRESS_SET

	MOV R7, #624 ;-AREA OF THE PHOTO, 39 X 47
	LDR R5, =NEON_START

	;MEMORY WRITE
	MOV R2, #0x2C
	BL LCD_COMMAND_WRITE
IMAGE_LOOP5
	LDR R6, [R5], #2	;POST INCREMENT
	MOV R2, R6
	BL LCD_16_DATA_WRITE
	SUB R7, R7, #1
	CMP R7, #0
	BGT IMAGE_LOOP5

	POP {R0-R7, PC}

	ENDFUNC
	
	
START FUNCTION
	PUSH {R0-R12,LR}
	
	;INITILAIZING SCORE, COLLIDED FOR BOTH PLAYERS (ASSUMING WE DO MULTIPLAYER, IF NOT WE REMOVE SCORE)
	PUSH {R0,R1}
	LDR R0,=PLAYER_1_SCORE   	; MAIN PLAYER SCORE
	MOV R1,#0
	STRH R1,[R0]
	POP {R0,R1}
	
	PUSH {R0,R1}
	LDR R0,=PLAYER_2_SCORE                ; 2ND PLAYER SCORE
	MOV R1,#0
	STRH R1,[R0]
	POP {R0,R1}
	
	PUSH {R0,R1}
	LDR R0,=MAIN_COLLIDED               ; MAIN PLAYER COND
	MOV R1,#0
	STRH R1,[R0]
	POP {R0,R1}
	
	PUSH {R0,R1}
	LDR R0,=COMP_COLLIDED               ; 2ND PLAYER COND
	MOV R1,#0
	STRH R1,[R0]
	POP {R0,R1}
	
	BL DRAW_NEON
	POP {R0-R12,PC}
	ENDFUNC 	

;##################################################################################################################################################################
DRAW_BULLET_CHAR_D	FUNCTION
	;THIS FUNCTION TAKES STARTING X AND STARTING Y THEN DRAWS AN IMAGE
	;ARGUMENTS: R0 = X, R1 = Y
	PUSH{R0-R10, LR}
	
	LDR R8, =SPRITE_X
	LDR R7, =SPRITE_Y
	LDR R0, [R8]
	LDR R1, [R7]
	ADD R5, R0, #18
	ADD R6, R1, #27
	LDR R9, =BULLET_CHAR_DOWN
	LDRH R10, [R9]
	MOV R4, #0xFF
	LSL R4, #8
	ADD R4, R4, #0xFE
	
LOOP_CHAR_Y
	LDR R0, [R8]
	SUB R0, R0, #1
LOOP_CHAR_X
	CMP R10, R4
	BEQ SKIP_CHAR_P
	BL DRAWPIXEL
SKIP_CHAR_P
	ADD R0, R0, #1
	LDRH R10, [R9], #2
	CMP R0, R5
	BNE LOOP_CHAR_X
	ADD R1, R1, #1
	CMP R1, R6
	BNE LOOP_CHAR_Y
 
	POP {R0-R10, PC}

	ENDFUNC
;##################################################################################################################################################################
DRAW_BULLET_CHAR_R	FUNCTION
	;THIS FUNCTION TAKES STARTING X AND STARTING Y THEN DRAWS AN IMAGE
	;ARGUMENTS: R0 = X, R1 = Y
	PUSH{R0-R10, LR}
	
	LDR R8, =SPRITE_X
	LDR R7, =SPRITE_Y
	LDR R0, [R8]
	LDR R1, [R7]
	ADD R5, R0, #18
	ADD R6, R1, #27
	LDR R9, =BULLET_CHAR_RIGHT
	LDRH R10, [R9]
	MOV R4, #0xFF
	LSL R4, #8
	ADD R4, R4, #0xFE
	
LOOP_CHAR_Y_R
	LDR R0, [R8]
	SUB R0, R0, #1
LOOP_CHAR_X_R
	CMP R10, R4
	BEQ SKIP_CHAR_P_R
	BL DRAWPIXEL
SKIP_CHAR_P_R
	ADD R0, R0, #1
	LDRH R10, [R9], #2
	CMP R0, R5
	BNE LOOP_CHAR_X_R
	ADD R1, R1, #1
	CMP R1, R6
	BNE LOOP_CHAR_Y_R
 
	POP {R0-R10, PC}

	ENDFUNC
;##################################################################################################################################################################
DRAW_BULLET_CHAR_L	FUNCTION
	;THIS FUNCTION TAKES STARTING X AND STARTING Y THEN DRAWS AN IMAGE
	;ARGUMENTS: R0 = X, R1 = Y
	PUSH{R0-R10, LR}
	
	LDR R8, =SPRITE_X
	LDR R7, =SPRITE_Y
	LDR R0, [R8]
	LDR R1, [R7]
	ADD R5, R0, #18
	ADD R6, R1, #27
	LDR R9, =BULLET_CHAR_LEFT
	LDRH R10, [R9]
	MOV R4, #0xFF
	LSL R4, #8
	ADD R4, R4, #0xFE
	
LOOP_CHAR_Y_L
	LDR R0, [R8]
	SUB R0, R0, #1
LOOP_CHAR_X_L
	CMP R10, R4
	BEQ SKIP_CHAR_P_L
	BL DRAWPIXEL
SKIP_CHAR_P_L
	ADD R0, R0, #1
	LDRH R10, [R9], #2
	CMP R0, R5
	BNE LOOP_CHAR_X_L
	ADD R1, R1, #1
	CMP R1, R6
	BNE LOOP_CHAR_Y_L
 
	POP {R0-R10, PC}

	ENDFUNC
;##################################################################################################################################################################
DRAW_BULLET_CHAR_U	FUNCTION
	;THIS FUNCTION TAKES STARTING X AND STARTING Y THEN DRAWS AN IMAGE
	;ARGUMENTS: R0 = X, R1 = Y
	PUSH{R0-R10, LR}
	
	LDR R8, =SPRITE_X
	LDR R7, =SPRITE_Y
	LDR R0, [R8]
	LDR R1, [R7]
	ADD R5, R0, #18
	ADD R6, R1, #27
	LDR R9, =BULLET_CHAR_UP
	LDRH R10, [R9]
	MOV R4, #0xFF
	LSL R4, #8
	ADD R4, R4, #0xFE
	
LOOP_CHAR_Y_U
	LDR R0, [R8]
	SUB R0, R0, #1
LOOP_CHAR_X_U
	CMP R10, R4
	BEQ SKIP_CHAR_P_U
	BL DRAWPIXEL
SKIP_CHAR_P_U
	ADD R0, R0, #1
	LDRH R10, [R9], #2
	CMP R0, R5
	BNE LOOP_CHAR_X_U
	ADD R1, R1, #1
	CMP R1, R6
	BNE LOOP_CHAR_Y_U
 
	POP {R0-R10, PC}

	ENDFUNC
;##################################################################################################################################################################
LOCATION_INIT FUNCTION
	PUSH{R0-R2, LR}
	LDR R0, =SPRITE_X
    LDR R1, =SPRITE_Y
	MOV R2 , #220
	STR R2, [R0]
	MOV R2 , #0
	STR R2 ,[R1]
	LDR R0, =TILE_X
	MOV R2, #0
	STR R2, [R0]
	LDR R0, =TILE_Y
	STR R2, [R0]
	POP {R0-R2, PC}
	ENDFUNC
;##################################################################################################################################################################
BULLET_BG FUNCTION
    PUSH {R0-R8, LR}
	LDR R6, =BG_ARRAY        
    MOV R7, #10
    MOV R1, #0      ; Y coordinate
Y_LOOP
    MOV R0, #0      ; X coordinate
X_LOOP
	LDRB R8 ,[R6]
	ADD R6,#1;
    CMP R8, #0      
    BEQ DRAW_G 

    CMP R8, #1      
    BEQ DRAW_R 
 
DRAW_G
	PUSH{R0-R7}
	MOV R3, R1
;	ADD R1, R0, #38
;	ADD R4, R3, #46 ;I KNOW THE HEIGHT IS MORE THAN THE IMAGE, BUT THE EXTRA HEIGHT IS JUST A SAFE MEASURE TO AVOID OVERLAPPING, THE WIDTH SHOULD STRICTLY BE THE SAME AS YOUR PICTURE.

	ADD R1, R0, #31
	ADD R4, R3, #32 ;I KNOW THE HEIGHT IS MORE THAN THE IMAGE, BUT THE EXTRA HEIGHT IS JUST A SAFE MEASURE TO AVOID OVERLAPPING, THE WIDTH SHOULD STRICTLY BE THE SAME AS YOUR PICTURE.

	BL ADDRESS_SET

	MOV R7, #1024 ;-AREA OF THE PHOTO, 39 X 47
	LDR R5, =GRASS

	;MEMORY WRITE
	MOV R2, #0x2C
	BL LCD_COMMAND_WRITE
IMAGE_LOOPGRASS
	LDR R6, [R5], #2	;POST INCREMENT
	MOV R2, R6
	BL LCD_16_DATA_WRITE
	SUB R7, R7, #1
	CMP R7, #0
	BGT IMAGE_LOOPGRASS
	POP{R0-R7}
    ADD R0, R0, #TILE_WIDTH  ; Move to the next position on the X-axis
    CMP R0, #SCREEN_WIDTH
    BLT X_LOOP
    ADD R1, R1, #TILE_HEIGHT ; Move to the next position on the Y-axis
    CMP R1, #SCREEN_HEIGHT
    BLT Y_LOOP
DRAW_R
	PUSH{R0-R7}
	MOV R3, R1
 

	ADD R1, R0, #31
	ADD R4, R3, #32 ;I KNOW THE HEIGHT IS MORE THAN THE IMAGE, BUT THE EXTRA HEIGHT IS JUST A SAFE MEASURE TO AVOID OVERLAPPING, THE WIDTH SHOULD STRICTLY BE THE SAME AS YOUR PICTURE.

	BL ADDRESS_SET

	MOV R7, #1024 ;-AREA OF THE PHOTO, 39 X 47
	LDR R5, =ROAD

	;MEMORY WRITE
	MOV R2, #0x2C
	BL LCD_COMMAND_WRITE
IMAGE_LOOPROAD
	LDR R6, [R5], #2	;POST INCREMENT
	MOV R2, R6
	BL LCD_16_DATA_WRITE
	SUB R7, R7, #1
	CMP R7, #0
	BGT IMAGE_LOOPROAD
	POP{R0-R7}
	ADD R0, R0, #TILE_WIDTH  ; Move to the next position on the X-axis
    CMP R0, #SCREEN_WIDTH
    BLT X_LOOP
    ADD R1, R1, #TILE_HEIGHT ; Move to the next position on the Y-axis
    CMP R1, #SCREEN_HEIGHT
    BLT Y_LOOP

    POP {R0-R8, PC}
	ENDFUNC
	END
